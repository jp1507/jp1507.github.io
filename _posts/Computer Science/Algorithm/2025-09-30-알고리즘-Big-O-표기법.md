---
title: "[알고리즘] Big-O 표기법"
date: 2025-09-30
categories: [Computer Science, Algorithm]
tags: [Game Engineering, algorithm, coding test, cpp, Big-O, time complexity, space complexity, 게임공학, 알고리즘, 코딩테스트, C++, 빅오, 빅오 표기법, 시간 복잡도, 공간 복잡도]
series: "알고리즘"
series_order : 1
pin: false
math: true
image:
  path: https://imgur.com/QCj6GGe.jpg
---

## 알고리즘 성능 측정

---

내가 작성한 알고리즘에 대해 실행 속도가 얼마나 빠를지, 메모리는 또 얼마나 사용할지 고민하는 것은 당연하다. 하지만 성능을 측정하겠다고 실제로 일일히 입력을 만들어서 시간을 재는 것은 매우 불편하고 번거로운 일이다. 또 프로그래밍 언어, 하드웨어, 운영체제 등 수많은 요인에 의해 결과가 바뀔 수 있다. 이럴 때 객관적인 지표로 사용할 수 있는 복잡도 분석과 Big-O 표기법을 활용하면 된다.

## 복잡도 분석

---

복잡도 분석은 성능을 예측하는 방법론이다. 입력 크기 $n$에 따라 속도와 메모리 사용량이 얼마나 변하는지 분석한다. 복잡도에는 **공간 복잡도**와 **시간 복잡도**가 있다. 동일한 기능을 수행하는 알고리즘이라면 일반적으로 복잡도가 낮을 수록 좋은 알고리즘이다.

- 공간 복잡도
  : 특정한 크기의 입력에 대해 알고리즘이 실행될 때 사용되는 메모리 양(메모리의 발전으로 중요도 하락)
- 시간 복잡도
  : 특정한 크기의 입력에 대해 알고리즘이 실행될 때 수행되는 조작의 수

## 시간 복잡도

---

시간 복잡도는 3가지 경우로 나타낸다. 이 중에서 알고리즘이 복잡해질수록 평균적인 경우는 구하기 매우 어려워지기 때문에 보통 **최악의 경우**로 알고리즘의 성능을 측정한다.

1. 최선의 경우(Best Case)
   - Big-Omega 표기법
   - 최선의 시나리오에서의 시간 측정
2. 최악의 경우(Worst Case)
   - Big-O 표기법
   - 최악의 시나리오에서 시간 측정
3. 평균적인 경우(Average Case)
   - Big-Theta 표기법
   - 평균 시간을 측정

따라서 시간 복잡도는 최악의 경우인 **빅오(Big-O) 표기법**으로 나타낸다. 입력이 무한대로 발산할 때 연산 횟수를 다항식으로 표현하고, 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시켜 단순화한다.

![이미지1](https://imgur.com/72Hl8hl.png)

## 시간 복잡도 표기

---

### O($1$) - 상수 시간(Constant time)

입력 $n$에 상관없이 일정한 연산을 수행한다.  
```cpp
void func (int n) 
{
  std::cout << n << std::endl;
}
```

### O($\log{n}$) - 로그 시간(Logarithmic time)

입력 $n$이 커질 수록 연산 횟수가 $\log{n}$에 비례해서 증가한다.
```cpp
for(int i = 0; i <= n; i *= 2)
{
  std::cout << i << std::endl;
}
```

### O($n$) - 선형 시간(Linear time)

입력 $n$이 커질 수록 연산 횟수가 $n$에 비례해서 증가한다.
```cpp
for(int i = 0; i < n; i++)
{
  std::cout << i << std::endl;
}
```

### O($n^2$) - 2차 시간(Quadratic time)

입력 $n$이 커질 수록 연산 횟수가 $n^2$에 비례해서 증가한다.
```cpp
for(int i = 0; i < n; i++)
{
  for(int j = 0; j < n; j++)
  {
    std::cout << i << ", " << j << std::endl;
  }
}
```

### O($C^n$) - 지수 시간(Exponential time)

입력 $n$이 커질 수록 연산 횟수가 $C^n$에 비례해서 증가한다.
```cpp
int Fibonacci (int n) {
  if (n <= 1) 
    return n;

  return Fibonacci(n-1) + Fibonacci(n-2);
}
```

## 시간 복잡도 계산

---

- 하나의 루프를 사용하여 단일 요소 집합을 반복하는 경우 : O($n$)
- 단일 컨테이너의 절반 이상을 반복하는 경우 : O($n / 2$) → O($n$)
- 2개의 다른 루프를 사용하여 두 개의 개별 컨테이너를 반복하는 경우 : O($n + m$) → O($n$)
- 2개의 중첩 루프를 사용하여 단일 컨테이너를 반복할 경우 : O($n^2$)
- 2개의 중첩 루프를 사용하여 두 개의 개별 컨테이너를 반복하는 경우 : O($n * m$) → O($n^2$)
- 정렬 알고리즘을 사용하는 경우 : O($n\log{n}$)

## 정렬 알고리즘의 시간 복잡도 비교

---

| Sorting Algorithm | 공간 복잡도  | 시간 복잡도     |
| :---------------- | :----------- | :-------------- |
| Bubble Sort       | O($1$)       | O($n^2$)        |
| Heap Sort         | O($1$)       | O($n\log{n}$)   |
| Insertion Sort    | O($1$)       | O($n^2$)        |
| Merge Sort        | O($n$)       | O($n\log{n}$)   |
| Quick Sort        | O($\log{n}$) | O($n^2$)        |
| Selection Sort    | O($1$)       | O($n^2$)        |
| Shell Sort        | O($1$)       | O($n\log{n^2}$) |
| Smooth Sort       | O($1$)       | O($n\log{n}$)   |

## 자료구조의 시간 복잡도 비교

---

| Data Structures    | Search       | Insert       | Delete       |
| :----------------- | :----------- | :----------- | :----------- |
| Array              | O($n$)       | -            | -            |
| Sorted Array       | O($\log{n}$) | O($n$)       | O($n$)       |
| Linked List        | O($n$)       | O($1$)       | O($1$)       |
| Double Linked List | O($n$)       | O($1$)       | O($1$)       |
| Stack              | O($n$)       | O($1$)       | O($1$)       |
| Hash table         | O($n$)       | O($n$)       | O($n$)       |
| Binary Search Tree | O($n$)       | O($n$)       | O($n$)       |
| B-Tree             | O($\log{n}$) | O($\log{n}$) | O($\log{n}$) |
| Red-Black Tree     | O($\log{n}$) | O($\log{n}$) | O($\log{n}$) |
| AVL Tree           | O($\log{n}$) | O($\log{n}$) | O($\log{n}$) |
