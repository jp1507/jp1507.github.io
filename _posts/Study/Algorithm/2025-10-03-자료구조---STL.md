---
title: 자료구조 - STL
date: 2025-10-01
categories: [Computer Science, Data Structure]
tags: [Computer Science, Data Structure, Unity, Unreal, STL, 컴퓨터공학, 자료구조, 유니티, 언리얼]
pin: false
math: true
image:
  path: https://imgur.com/QCj6GGe.jpg
---

## 1. STL

---

### 1.1 STL이란

STL(Standard Template Library)은 C++ 표준 라이브러리의 일종으로, 효율적인 알고리즘과 자료구조를 제공하는 일련의 템플릿 클래스와 함수를 포함한다. 말그대로 표준 템플릿 라이브러리로 다양한 프로그램 개발에서 필요한 공통적인 작업들을 효율적으로 처리할 수 있도록 지원한다.

- 템플릿
  : 데이터 타입에 의존하지 않고 일반화된 코드를 작성하는 C++의 기능 중 하나이다. 쉽게 말해, 템플릿을 이용하면 하나의 코드로 다양한 데이터 타입을 처리할 수 있다.

### 1.2 STL의 구성요소

STL은 크게 컨테이너, 반복자, 알고리즘의 3가지 구성요소로 이루어져있다. 이 요소들은 서로 긴밀하게 연결되어 있어, 함께 사용될 때 STL을 효율적으로 활용할 수 있다.

1. 컨테이너의 정의와 종류
   : 컨테이너는 데이터를 담는 그릇이다. 템플릿의 형태로 제공되며 동적으로 크기가 변경 가능한 컨테이너와 고정된 크기를 가진 컨테이너 등 다양한 형태가 있고 특정한 데이터 구조를 나타내는 컨테이너들도 있다.

2. 반복자의 정의와 종류
   : 반복자는 컨테이너의 원소들을 순회하거나 접근하는 방법을 제공하는 객체이다. 반복자는 포인터와 유사하게 동작하며, 다양한 종류의 반복자가 있다. 반복자를 이용하면 STL의 알고리즘을 일관된 방식으로 적용할 수 있다.

3. 알고리즘의 정의와 종류
   : 알고리즘은 정렬, 검색, 복사 등 특정한 작업을 수행하는 함수들을 의미한다. 함수 템플릿 형태로 제공되며, 대부분의 알고리즘은 반복자를 통해 컨테이너의 원소에 접근한다. 이로 인해 STL의 알고리즘은 다양한 컨테이너에 일관된 방식으로 적용될 수 있다.

### 1.3 STL의 장점과 특징

STL을 이용하면 프로그래머가 보다 안정적이고 신뢰성 있는 코드를 작성할 수 있다. STL은 효율적인 알고리즘과 컨테이너를 제공하며, 이들을 통해 복잡한 데이터 구조와 알고리즘을 쉽게 이해하고 활용할 수 있다.

- 일관성 있는 인터페이스 : 모든 컴포넌트는 일관된 인터페이스를 제공하므로 한번 사용 방법을 익히면 여러 컨테이너와 알고리즘을 쉽게 사용할 수 있다.
- 코드 재사용 : 템플릿 형태로 제공되므로, 자신의 데이터 타입에 맞게 이들을 사용할 수 있고 코드 재사용이 용이해진다.
- 효율성 : 효율적인 알고리즘과 컨테이너로 성능 최적화에 신경쓰지 않고 빠르게 효율적인 코드를 작성할 수 있다.
- 확장성 : STL을 확장하여 자신만의 컨테이너나 알고리즘을 개발할 수 있고 자신의 문제에 최적화된 코드를 작성할 수 있다.
- 추상화 : 반복자와 알고리즘을 통해 데이터 구조와 작업을 추상화하므로 더 높은 수준에서 문제를 생각할 수 있다.
- 유지보수 : STL은 표준 라이브러리이므로, 작성한 코드가 다른 플랫폼에서도 동작할 것임을 확신할 수 있고 버그를 찾거나 유지보수하는데 도움이 된다.

## 2. 시퀀스 컨테이너

---

시퀀스 컨테이너는 STL의 핵심 컨테이너 중 하나로, 데이터를 선형적으로 저장한다. 이를 통해 사용자는 데이터를 원하는 순서대로 저장하고 접근할 수 있다.

### 2.1 vector

vector는 STL 시퀀스 컨테이너 중 하나로, **동적 배열**을 구현한 것이다.

1. 정의와 특징
  : vector의 주요 특징 중 하나는 메모리를 연속적으로 할당한다는 점이다. 이는 데이터에 빠르게 접근할 수 있다는 장점을 가지며 인덱스를 통해 데이터에 접근하는 것이 가능하다는 뜻이다. 하지만 이러한 연속 메모리 할당 방식은 vector의 크기가 변경될 때마다 메모리를 새롭게 할당하고, 기존 데이터를 새 위치로 복사해야하며, 이때 크기 변경에 대한 비용이 발생하는 단점이 있다.

2. vector의 사용 예제

    ```cpp
    #include <vector>
    #include <iostream>

    int main() {
        std::vector<int> vec;  // 정수형 vector 생성

        // 데이터 추가
        for (int i = 0; i < 10; ++i) {
            vec.push_back(i);
        }

        // 데이터 접근 및 출력
        for (int i = 0; i < vec.size(); ++i) {
            std::cout << "Element [" << i << "]: " << vec[i] << std::endl;
        }

        return 0;
    }
    ```
  
3. vector의 심화적 사용

    ```cpp
    #include <vector>
    #include <iostream>

    int main() {
        std::vector<int> vec;  // 정수형 vector 생성

        // 데이터 추가
        for (int i = 0; i < 10; ++i) {
            vec.push_back(i);
        }

        vec.resize(15, 100);  // 크기를 15로 변경하고, 새로운 요소는 100으로 초기화

        // iterator를 사용한 데이터 접근 및 출력
        for (auto it = vec.begin(); it != vec.end(); ++it) {
            std::cout << "Element: " << *it << std::endl;
        }

        return 0;
    }
    ```

### 2.2 list

list는 STL의 시퀀스 컨테이너 중 하나로 **이중 연결 리스트**를 구현한 것이다. 이중 연결 리스트는 각 노드가 이전 노드와 다음 노드에 대한 참조를 갖는 자료구조를 말한다.

1. list의 정의와 특징

   : list의 주요 특징은 임의의 위치에서의 삽입과 삭제가 상수 시간에 가능하다는 점이다. 즉, list는 데이터의 삽입과 삭제가 빈번하게 발생하는 상황에서 효율적으로 사용할 수 있다. 하지만 list는 메모리를 연속적으로 할당하지 않기 때문에 인덱스를 통한 랜덤 접근이 불가능하다. 특정 위치의 데이터에 접근하기 위해서는 처음부터 차례대로 접근해야 하므로 비효율이 발생할 수 있다.

2. list의 사용 예제

    ```cpp
    #include <list>
    #include <iostream>

    int main() {
        std::list<int> lst;  // 정수형 list 생성

        // 데이터 추가
        for (int i = 0; i < 10; ++i) {
            lst.push_back(i);
        }

        // 데이터 접근 및 출력
        for (auto it = lst.begin(); it != lst.end(); ++it) {
            std::cout << "Element: " << *it << std::endl;
        }

        return 0;
    }
    ```

3. list의 심화적 사용법

    ```cpp
    #include <list>
    #include <iostream>

    int main() {
        std::list<int> lst;  // 정수형 list 생성

        // 데이터 추가
        for (int i = 0; i < 10; ++i) {
            lst.push_back(i);
        }

        auto it = lst.begin();
        std::advance(it, 5);  // iterator를 5칸 전진
        lst.insert(it, 100);  // 해당 위치에 100 추가

        // 데이터 삭제
        it = lst.begin();
        std::advance(it, 3);  // iterator를 3칸 전진
        lst.erase(it);  // 해당 위치의 요소 삭제

        // 데이터 접근 및 출력
        for (auto it = lst.begin(); it != lst.end(); ++it) {
            std::cout << "Element: " << *it << std::endl;
        }

        return 0;
    }
    ```

### 2.3 deque

deque는 Double Ended Queue의 약자로 양쪽 끝에서 삽입과 삭제가 모두 가능한 STL 컨테이너이다. vector와 마찬가지로 데이터를 연속적으로 저장하지만, 앞 뒤로 자료 삽입 및 삭제가 가능하다는 점이 다르다.

1. deque의 정의와 특징
   : deque의 가장 큰 특징은 양뱡향에서 데이터의 삽입과 삭제가 가능하다는 점이다. 이로 인해 queue와 stack의 장점을 모두 갖게 되어 유연한 프로그래밍이 가능하다. 하지만 덱의 중간 위치에 있는 원소에 접근하는 것은 비교적 느린 편이며, 메모리 할당도 vector보다 불규칙하다.

2. deque의 사용 예제
   : deque은 스케줄링, 캐시 등의 알고리즘에서 유용하게 사용된다. 또한 연속적인 메모리 공간에 데이터를 저장하는 vector와 달리, 여러 개의 비연속적 메모리 블록에서 객체를 관리하므로, 큰 데이터 세트를 다룰 때에도 메모리 부족 문제를 효과적으로 해결할 수 있다.
  
    ```cpp
    std::deque<int> d;

    d.push_back(5); // 덱 뒤에 5 추가 {5}
    d.push_front(3); // 덱 앞에 3 추가 {3, 5}
    d.pop_back(); // 덱 뒤에 있는 원소 삭제 {3}
    d.pop_front(); // 덱 앞에 있는 원소 삭제 {}
    ```
  
3. deque의 심화적 사용법

    ```cpp
    #include <iostream>
    #include <deque>

    int main() {
        std::deque<int> d;
        for(int i = 0; i < 10; ++i) {
            if(i % 2 == 0) d.push_front(i);
            else d.push_back(i);
        }

        // 덱의 모든 원소를 출력
        for(int i = 0; i < d.size(); ++i) {
            std::cout << d[i] << ' ';
        }

        return 0;
    }
    ```

## 3. 컨테이너 어댑터

---

컨테이너 어댑터는 기본 STL 컨테이너의 기능을 특정한 인터페이스에 맞게 변형하는 역할을 한다. 내부에서 deque나 list 등을 사용하며, 컨테이너의 기능을 제한적이지만 편리하게 제공한다.

### 3.1 stack

1. stack의 정의와 특징
   : stack은 컨테이너 어댑터 중 하나로, 데이터를 LIFO(Last In First Out) 방식으로 저장한다. 이는 가장 최근에 저장된 요소가 먼저 추출되는 특징을 가진다. 컴퓨터 메모리 구조와 비슷하게 작동하며, 프로그램의 함수 호출 스택에서 볼 수 있다.

2. stack의 사용 예제
   : stack은 재귀함수를 구현할 때 또는 후위 표기법 계산 등 다양한 알고리즘에 유용하게 쓰인다.

    ```cpp
    #include <stack> 
    std::stack<int> s; // int 타입을 저장하는 stack

    s.push(1); // stack에 1을 추가합니다. stack: {1}
    s.push(2); // stack에 2를 추가합니다. stack: {1, 2}
    s.pop();   // stack의 가장 위 요소를 제거합니다. stack: {1}
    s.top();   // stack의 가장 위 요소를 반환합니다. 여기서는 1을 반환합니다.
    ```

### 3.2 queue

1. queue의 정의와 특징
   : queue는 컨테이너 어댑터 중 하나로, 요소들을 FIFO(First In First Out) 방식으로 저장한다. 즉, 먼저 들어온 요소가 먼저 나가는 구조를 가지고 있다. 대기열에서 볼 수 있는 기본적인 동작을 모방한다.

2. queue 사용 예제
   : queue는 스케줄링, 이벤트 드리븐 프로그래밍, 캐시 알고리즘 등 다양한 알고리즘에서 사용된다.  
  
    ```cpp
    #include <queue> 

    std::queue<int> q; // int 타입을 저장하는 queue
    q.push(1); // queue에 1을 추가합니다. queue: {1}
    q.push(2); // queue에 2를 추가합니다. queue: {1, 2}
    q.pop();   // queue의 가장 앞 요소를 제거합니다. queue: {2}
    q.front(); // queue의 가장 앞 요소를 반환합니다. 여기서는 2를 반환합니다.
    ```

### 3.3 priority_queue

1. priority_queue의 정의와 특징

   : priority_queue는 컨테이너 어댑터 중 하나로, 요소를 우선순위에 따라 저장하고 관리한다. 기본적으로 priority_queue는 `less` 연산자를 이용해 요소를 비교하므로 큰 값이 높은 우선순위를 가진다.

2. priority_queue 사용 예제
     : priority_queue는 다익스트라 알고리즘, 힙 정렬, 베스트 퍼스트 서치 등 다양한 알고리즘에 사용된다. STL의 priority_queue를 사용하면 복잡한 우선순위 로직을 쉽게 구현할 수 있다.

    ```cpp
    #include <queue> 

    std::priority_queue<int> pq; // int 타입을 저장하는 priority_queue

    pq.push(3); // priority_queue에 3을 추가합니다. pq: {3}
    pq.push(1); // priority_queue에 1을 추가합니다. pq: {3, 1}
    pq.push(2); // priority_queue에 2을 추가합니다. pq: {3, 2, 1}
    pq.top();   // priority_queue의 최상위 요소를 반환합니다. 여기서는 3을 반환합니다.
    ```

## 4. 연관 컨테이너

연관 컨테이너는 키(Key)를 기반으로 요소를 저장하고, 조회하는 컨테이너이다. 빠른 검색 속도를 제공하며 키에 따라 자동으로 정렬된다. 중복 키를 허용하는 컨테이너와 아닌 컨테이너 등이 있다.

### 4.1 set

1. set의 정의와 특징
   : set은 연관 컨테이너 중 하나로,키의 유일성을 보장하는 구조이다. 즉, 동일한 값을 가진 요소를 여러 개 저장하지 않는다. 저장된 요소는 특정 기준에 따라 자동으로 정렬되고, 기본적으로 오름차순 정렬이지만 사용자가 직점 비교 함수를 제공할 수 있다.

2. set의 사용 예제

    ```cpp
    #include <iostream>
    #include <set>

    int main() {
        std::set<int> s;

        // 요소 추가
        s.insert(3);
        s.insert(1);
        s.insert(5);
        s.insert(2);

        // 요소 출력
        for (int i : s) {
            std::cout << i << ' ';
        }

        return 0;
    }
    ```

3. set의 심화 사용법
   : set은 중복된 요소를 허용하지 않는 것 외에도, 특정 요소가 set에 포함되어 있는지 여부를 빠르게 검사할 수 있다. 이는 다음과 같은 `find()`함수를 사용하여 수행할 수 있다.

    ```cpp
    if (s.find(3) != s.end()) {
        std::cout << "3은 셋에 있습니다.";
    } else {
        std::cout << "3은 셋에 없습니다.";
    }
    ```

### 4.2 multiset

1. multiset의 정의와 특징
   : multiset은 set과 유사하지만 동일한 값을 가진 여러 개의 요소를 저장할 수 있는 차이점이 있다. 저장된 요소는 마찬가지로 기준에 따라 자동으로 정렬된다. 기본적으로 오름차순 정렬이지만 사용자가 직접 비교 함수를 제공할 수 있다

2. multiset의 사용 예제

    ```cpp
    #include <iostream>
    #include <set>

    int main() {
        std::multiset<int> ms;

        // 요소 추가
        ms.insert(3);
        ms.insert(1);
        ms.insert(3);
        ms.insert(2);

        // 요소 출력
        for (int i : ms) {
            std::cout << i << ' ';
        }

        return 0;
    }
    ```

3. multiset의 심화 사용법

    ```cpp
    // 사용자 정의 비교 함수
    struct comp {
        bool operator() (const int& a, const int& b) const {
            return a > b;
        }
    };

    // 사용자 정의 비교 함수를 사용하여 multiset 선언
    std::multiset<int, comp> ms;

    // 요소 추가 및 출력
    ms.insert(3);
    ms.insert(1);
    ms.insert(3);
    ms.insert(2);

    for (int i : ms) {
        std::cout << i << ' ';
    }
    ```

### 4.3 map

1. map의 정의와 특징
   : map에서 가장 중요한 특징은 키에 대해 정렬이 유지되는 점이다. 이는 검색, 제거, 삽입 작업이 로그 시간에 수행될 수 있도록 보장한다. 키는 컨테이너 내에서 유일하며 서로 다른 키와 연결된 값은 동일할 수 있다.

2. map의 사용 예제
   
    ```cpp
    #include <iostream>
    #include <map>

    int main() {
    // map 선언
    std::map<std::string, int> m;

    // 값 추가
    m["apple"] = 10;
    m["banana"] = 20;
    m["cherry"] = 30;

    // 값 접근 및 출력
    std::cout << "apple: " << m["apple"] << '\n';
    std::cout << "banana: " << m["banana"] << '\n';
    std::cout << "cherry: " << m["cherry"] << '\n';

    return 0;
    }
    ```

3. map의 심화 사용법
   : map은 존재하지 않는 키로 접근하면 해당 키와 기본으로 초기화된 값을 가진 새로운 요소를 자동으로 생성한다.

    ```cpp
    #include <iostream>
    #include <map>

    int main() {
        std::map<std::string, int> m;

        // 이전에 없던 키로 접근
        std::cout << m["plum"] << '\n'; // 출력: 0

        // 키 "plum"이 map에 추가되어 있음을 확인
        for (const auto& pair : m) {
            std::cout << pair.first << ": " << pair.second << '\n';
        }

        return 0;
    }
    ```

### 4.4 multimap

1. multimap의 정의와 특징
   : map에서는 각 키가 유일해야하는 반면 multimap에서는 동일한 키를 가진 여러 요소가 허용된다. 즉, multimap은 하나의 키에 여러 값이 연결될 수 있다. 키에 대한 정렬 순서를 유지하며, 검색, 삽입, 삭제가 로그 시간에 이루어진다. 키는 비교 가능한 타입이어야 하며, 값은 어떠한 타입이든 가능하다.

2. multimap 사용 예제

    ```cpp
    #include <iostream>
    #include <map>

    int main() {
        // multimap 선언
        std::multimap<std::string, int> mm;

        // 값 추가
        mm.insert({"apple", 10});
        mm.insert({"apple", 20});
        mm.insert({"banana", 30});

        // 값 접근 및 출력
        auto range = mm.equal_range("apple");
        for (auto i = range.first; i != range.second; ++i) {
            std::cout << i->first << ": " << i->second << '\n';
        }

        return 0;
    }
    ```

3. multimap의 심화적 사용법
   : 동일한 키를 가진 요소에 액세스하려면 `equal_range()` 함수를 사용할 수 있따. 이 함수는 해당 키의 첫 번째 요소와 마지막 요소를 가리키는 반복자 쌍을 반환한다. 이를 이용해 동일한 키를 가진 모든 요소를 출력하는 코드를 작성할 수 있다.

## 5. 비순차 컨테이너

---

### 5.1 unordered_set

1. unordered_set의 정의와 특징
   : unordered_set은 비순차 컨테이너 중 하나로, set과 마찬가지로 유일한 값을 저장하지만, 내부적으로 해시 테이블을 사용하여 값들을 저장하므로 원소의 순서를 보장하지 않는다. 따라서 이름처럼 **정렬되지 않는 집합**이다. 대신 해시 테이블을 사용하므로 일반적으로 상수 시간에 원소를 검색할 수 있다.

2. unordered_set의 사용 예제
  
    ```cpp
    #include <iostream>
    #include <unordered_set>

    int main() {
    std::unordered_set<int> myset;

    myset.insert(10);
    myset.insert(5);
    myset.insert(15);
    myset.insert(10); // 중복된 값은 무시됩니다.

    for(auto it = myset.begin(); it != myset.end(); ++it) {
        std::cout << *it << " ";
    }

    if(myset.find(5) != myset.end()) { // 값 5를 찾습니다.
        std::cout << "\n5 found in set.";
    }
    return 0;
    }
    ```

### 5.2 unordered_multiset

1. unordered_multiset의 정의와 특징
   : unordered_multiset은 비순차 컨테이너 중 하나로, 중복 값을 허용하는 특징이 있고 동일한 값을 가진 원소를 여러 개 저장할 수 있다. 해시 테이블을 기반으로 하므로 원소의 순서가 보장되지 않는다. 원소 검색, 삽입, 삭제에 있어 일반적으로 상수 시간이 걸리고 최악의 경우 선형 시간이 걸린다.

2. unordered_multiset의 사용 예제

    ```cpp
    #include <iostream>
    #include <unordered_set>

    int main() {
        std::unordered_multiset<int> myset;

        myset.insert(10);
        myset.insert(20);
        myset.insert(20);
        myset.insert(30);

        for(auto it = myset.begin(); it != myset.end(); ++it) {
            std::cout << *it << std::endl;
        }

        std::cout << "Count of 20: " << myset.count(20) << std::endl;
        
        if(myset.find(20) != myset.end()) {
            std::cout << "20 found in set.";
        }
        
        return 0;
    }
    ```

### 5.3 unordered_map

1. unordered_map의 정의와 특징
   : unordered_map은 비순차 컨테이너 중 하나로, key-value 쌍을 저장한다. 내부적으로 해시 테이블을 사용해서 원소의 순서를 보장하지 않는다. 데이터를 검색하는 데에 매우 효율적이며 일반적으로 상수 시간이, 최악의 경우 선형 시간이 걸린다.

2. unordered_map의 사용 예제

    ```cpp
    #include <iostream>
    #include <unordered_map>

    int main() {
        std::unordered_map<std::string, int> mymap;

        mymap["apple"] = 1;
        mymap["banana"] = 2;
        mymap["cherry"] = 3;

        for(auto it = mymap.begin(); it != mymap.end(); ++it) {
            std::cout << it->first << ": " << it->second << std::endl;
        }

        std::cout << "apple's value: " << mymap["apple"] << std::endl;
        
        if(mymap.find("banana") != mymap.end()) {
            std::cout << "banana found in map.";
        }
        
        return 0;
    }
    ```

### 5.4 unordered_multimap

1. unordered_multimap의 정의와 특징
   : unordered_multimap은 비순차 컨테이너 중 하나로, key-value 쌍을 저장하지만, 하나의 키에 대해 여러 값을 연결할 수 있는, 즉 중복 키를 허용한다는 특징이 있다.

2. unordered_multimap의 사용 예제

    ```cpp
    #include <iostream>
    #include <unordered_map>

    int main() {
        std::unordered_multimap<int, std::string> mymap;

        mymap.insert(std::make_pair(1, "Apple"));
        mymap.insert(std::make_pair(2, "Banana"));
        mymap.insert(std::make_pair(1, "Mango"));
        mymap.insert(std::make_pair(3, "Peach"));

        for(auto it = mymap.begin(); it != mymap.end(); ++it) {
            std::cout << it->first << " -> " << it->second << std::endl;
        }

        auto range = mymap.equal_range(1);
        for(auto i = range.first; i != range.second; ++i) {
            std::cout << i->first << " -> " << i->second << std::endl;
        }

        return 0;
    }
    ```

## 6. 반복자

---

### 6.1 반복자의 개념과 필요성

반복자(iterator)는 컨테이너에 저장된 요소에 대해 접근하는 방법을 제공한다. 반복자는 특정 컨테이너에 저장된 요소를 가리키는 객체라고 볼 수 있다.  

반복자의 필요성은 컨테이너가 제공하는 기본 인터페이스를 확장하려는 목적에서 비롯된다. 기본적으로 컨테이너는 삽입, 삭제, 조회 등의 연산을 제공하지만 이러한 연산들은 종종 부족할 수 있다. 이런 문제를 해결하기 위해 등장한 것이 반복자이다.  

반복자를 사용하면 컨테이너의 모든 요소를 효과적으로 순회할 수 있으므로 사용법을 익히면 STL 컨테이너를 더욱 쉽고 효과적으로 다룰 수 있고 다양한 상황에서 효율적인 프로그래밍이 가능해진다.

### 6.2 반복자의 종류와 사용 방법

STL에는 다양한 유형의 반복자를 제공한다. 이들은 컨테이너와 함께 사용되어 컨테이너의 요소를 쉽고 효과적으로 순회할 수 있다.

- 입력 반복자(Input Iterators) : 읽기만 가능한 반복자이고 한 번 읽은 요소는 다시 읽을 수 없다.
- 출력 반복자(Output Iterators) : 쓰기만 가능한 반복자이고 한 번 쓴 요소는 다시 쓸 수 없다.
- 전진 반복자(Forward Iterators) : 읽기와 쓰기가 모두 가능한 반복자이고 한 번 순회한 요소는 다시 순회할 수 있다.
- 양방향 반복자(Bidirectional Iterators) : 전진 반복자의 모든 기능을 가지며 이전 요소로 이동할 수 있다.
- 랜덤 접근 반복자(Random Access Iterators) : 양방향 반복자의 모든 기능을 가지며 임의의 위치로 점프할 수 있다.

### 6.3 컨테이너와 반복자의 상호작용

1. 컨테이너와 반복자 간 상호작용

   : 컨테이너는 원소들의 집합을 저장하고, 반복자는 그 원소들을 순회하는 데 사용된다. 반복자는 포인터와 유사한 개념으로, 원소들에 대한 접근 권한을 제공한다. 어떤 반복자는 읽기만 가능(const_iterator)하고, 어떤 반복자는 읽고 쓰기가 가능(iterator)하다.  

2. 컨테이너와 반복자의 상호작용 예제

    ```cpp
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::vector<int>::iterator it = vec.begin();

    while (it != vec.end()) {
        std::cout << *it << " ";  // 반복자를 통한 원소 접근
        ++it;  // 반복자 이동
    }
    ```

3. 컨테이너와 반복자의 심화적인 상호작용

    ```cpp
    std::list<int> lst = {1, 2, 3, 4, 5};
    std::list<int>::reverse_iterator rit = lst.rbegin();

    while (rit != lst.rend()) {
        std::cout << *rit << " ";  // 반복자를 통한 원소 접근
        ++rit;  // 반복자 이동
    }
    ```
