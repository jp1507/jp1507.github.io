---
title: "[자료구조] List"
date: 2025-10-05 12:00:00 +9000
categories: [Computer Science, Data Structure]
tags: [Computer Science, Data Structure, Unity, Unreal, list, 컴퓨터공학, 자료구조, 유니티, 리스트]
series: "[자료구조]"
series_order : 3
pin: false
math: true
image:
  path: https://imgur.com/yTRCTI0.jpg
---

## List의 특징

---

- 노드 기반 시퀀스 컨테이너로, 이중 연결 리스트를 기반으로 둔 순서를 유지하는 구조이다.
- vector나 deque와 다르게 랜덤 접근(`at()`, `[]` operator [])이 불가능하고, 양방향 반복자를 통해 탐색

## List의 선언

---

- `#include <list>`
<br>
- `list<Type> Var;` : 선언된 타입을 담는 리스트 생성
- `list<Type> Var(N);` : 선언된 타입의 기본 값으로 초기화된 N개의 원소를 담은 리스트 생성
- `list<Type> Var(N, M);` : 선언된 타입의 M 값으로 초기화된 N개의 원소를 담은 리스트 생성

## List의 Iterator

---

- `list.begin()` : 리스트의 시작 점의 주소 값 반환
- `list.end()` : 리스트의 끝 지점 + 1의 주소를 반환
- `list.rbegin()` : 리스트의 끝 지점을 시작 점으로 반환
- `list.rend()` : 리스트의 시작 - 1의 주소를 반환

## List의 원소 접근

---

- `list.front()` : 리스트의 첫 번째 원소 접근
- `list.back()` : 리스트의 마지막 원소 접근

## 기본 멤버 함수

---

- `push_front()` : 첫 번째에 원소 추가
- `push_back()` : 마지막에 원소 추가
- `pop_front()` : 첫 번째 원소 제거
- `pop_back()` : 마지막 원소 제거
- `insert(Pos, Value)` : 해당 위치에 원소 삽입, 반환 값은 삽입된 값은 삽입된 원소의 주소 값
- `erase(Pos)` : 해당 위치의 원소를 제거하고 제거한 원소 다음의 주소 값을 반환
- `remove(Value)`, `remove(Predicate)` : Value와 같은 원소, 또는 Predicate에 해당하는 원소를 모두 제거
- `reverse()` : 원소들의 순차열을 뒤집음
- `sort()`, `sort(Predicate)` : 모든 원소들을 기본 값인 오름차순 또는 Predicate로 정렬
- `swap()` : 해당 리스트와 스왑
- `splice(Pos1, list)` : Pos1 위치에 리스트의 모든 원소를 붙임
- `splice(Pos1, list, Pos2)` : Pos1 위치에 list의 Pos2에 해당하는 원소를 붙임
- `splice(Pos1, list, start, end)` : Pos1 위치에 list의 [start, end) 범위의 원소들을 붙임
- `unique()` : 연속한 모든 원소들을 하나를 제외하고 모두 제거
- `merge(list)`, `merge(list, Predicate)` : list를 기본 값인 오름차순, 또는 Predicate로 합병 정렬
- `clear()` : 모든 원소를 제거(size = 0)
- `empty()` : 비어있으면 `true`, 아니면 `false`를 반환
- `size()` : 크기를 반환
- `resize()` : size를 재설정(범위 초과 시 0으로 초기화)

```cpp
#include<iostream>
#include<list>
 
using namespace std;
 
bool predicate(int num){ return num >= 100 && num <= 200; }

int main(void)
{
    list<int> lt;
    lt.push_back(10);
    lt.push_back(20);
    lt.push_back(108);
    lt.push_back(60);
    lt.push_back(10);
    lt.push_back(100);
    lt.push_back(40);    
    lt.push_back(50);
    lt.push_back(10);
    lt.push_back(109);
    lt.push_back(30);    
    lt.push_back(220);
    lt.push_back(10);
        
    list<int>::iterator iter;
    
    cout << "orign) ";
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout <<*iter << " ";
    cout << endl;
    
    lt.remove_if(predicate);
    
    cout << "test1) " ; 
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout << *iter << " ";
    cout << endl;
    
    lt.remove(10);
    
    cout << "test2) ";
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout << *iter << " ";
    cout << endl;
    
    // unique & sort
    list<string> lt;
    lt.push_back("b");
    lt.push_back("c");
    lt.push_back("a");
    lt.push_back("q");
    lt.push_back("a");
    lt.push_back("a");
    lt.push_back("a");
    lt.push_back("k");
    lt.push_back("j");
    lt.push_back("p");
    lt.push_back("q");
    lt.push_back("o");
    lt.push_back("e");
    lt.push_back("a");
    lt.push_back("a");
 
    list<string>::iterator iter;
    
    cout << "orign) ";
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout <<*iter << " ";
    cout << endl;
 
    cout << "unique) ";
    lt.unique();
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout <<*iter << " ";
    cout << endl;
 
    cout << "sort 1) ";
    lt.sort();
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout <<*iter << " ";
    cout << endl;
 
    cout << "sort 2) ";
    lt.sort(greater<string>());
    for(iter = lt.begin(); iter!= lt.end(); iter++)
        cout <<*iter << " ";
    cout << endl;
    
    // splice
    list<int> lt1;
    lt1.push_back(100);
    lt1.push_back(200);
    lt1.push_back(300);
    lt1.push_back(400);
    lt1.push_back(500);
 
    list<int> lt2;
    lt2.push_back(111);
    lt2.push_back(444);
    lt2.push_back(555);
 
    list<int>::iterator iter;
    
    cout << "[lt1] orign) ";
    for(iter = lt1.begin(); iter!= lt1.end(); iter++)
        cout <<*iter << " ";
    cout << endl ;
 
    cout << "[lt2] orign) ";
    for(iter = lt2.begin(); iter!= lt2.end(); iter++)
        cout <<*iter << " ";
    
    cout << endl << "test 6) lt2.merge(lt1);"<< endl;
    lt2.merge(lt1);
    
    cout << "[lt1] merge) ";
    for(iter = lt1.begin(); iter!= lt1.end(); iter++)
        cout <<*iter << " ";
    cout << endl ;
 
    cout << "[lt2] merge) ";
    for(iter = lt2.begin(); iter!= lt2.end(); iter++)
        cout <<*iter << " ";
    cout << endl;
    
    return 0;    
}
```
