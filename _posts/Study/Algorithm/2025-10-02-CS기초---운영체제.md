---
title: CS기초 - 운영체제
date: 2025-10-02
categories: [Computer Science, Fundamentals]
tags: [Computer Science, algorithm, Unity, Unreal, OS, 컴퓨터공학, 알고리즘, 유니티, 언리얼, 운영체제]
series: "CS기초"
series_order : 2
pin: false
math: true
image:
  path: https://imgur.com/QCj6GGe.jpg
---

## 1. 운영체제

---

운영체제(Operating System, OS)란 하드웨어 위에 설치되어 하드웨어 계층과 다른 소프트웨어 계층을 연결하는 소프트웨어 계층이다. 컴퓨터 시스템의 자원을 관리하고, 사용자가 컴퓨터를 사용할 수 있는 환경을 제공한다.  

![이미지1](https://imgur.com/mIpWll8.png)

### 1.1 운영체제의 목적

1. 처리 능력 향상
   : 자원 관리를 통해 일정 시간 내에 시스템이 처리하는 일의 양을 향상시킴
2. 반환 시간 단축
   : 사용자가 시스템에 요청한 작업을 완료할 때까지 소요되는 시간을 단축시킴
3. 사용 가능도 향상
   : 사용자가 컴퓨터를 사용해야 할 때 자원을 즉시 사용할 수 있게 함
4. 신뢰도 향상
   : 입력 값에 대한 정확한 결과 값을 줄 수 있도록 함

### 1.2 운영체제의 핵심 기능

1. 자원 관리 : CPU, 메모리, 디스크 할당
2. 추상화 : 복잡한 하드웨어를 단순한 인터페이스로 제공
3. 보호 : 프로그램 간 간섭 금지
4. 공유 : 여러 프로그램이 자원을 효율적으로 공유

### 1.3 커널과 시스템 콜

커널(Kernal)은 OS의 핵심요소로, 컴퓨터 하드웨어와 프로세스의 보안, 자원 관리, 하드웨어 추상화 같은 중요한 역할을 수행한다. 자원 관리를 위해 CPU 스케쥴링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등을 담당한다.

![이미지2](https://imgur.com/wZUsrlL.png)

- 커널 모드
  : 중요 자원에 사용자가 쉽게 접근하지 못하도록 하는 모드이고, 하드웨어에 직접 접근해 메모리나 CPU와 같은 자원을 사용 가능
- 사용자 모드
  : 커널 모드의 자원에 접근할 수 없게 제한을 둔 모드

사용자 모드에서 실행된 프로세스가 자원에 접근하려면 시스템 콜을 호출해 커널에 요청을 해야한다. 커널은 시스템 콜로 받은 요청을 처리한 후 다시 시스템 콜로 결과 값을 반환한다.

### 1.4 시스템 콜

사용자 모드에서 커널 모드에 접근해 필요한 기능을 수행할 수 있게 하는 시스템 함수이다. 프로세스 제어, 파일 조작, 장치 관리, 데이터 유지 보수, 통신, 보호를 할 수 있다.

## 2. 프로세스

---

### 2.1 프로세스와 스레드

프로세스(Process)란 컴퓨터에서 실행 중인 하나의 프로그램을 의미한다.

**프로세스에 할당된 메모리 영역**

![이미지3](https://imgur.com/NCyEBiZ.png)

**프로세스 메모리 영역 구조**

![이미지4](https://imgur.com/BW0NZUh.png)

스택 영역은 LIFO(후입선출), 힙 영역은 FIFO(선입선출)이다. 메모리 영역을 공유하기 때문에 서로의 영역을 침범하는 문제가 생길 수 있으며 이때 스택 영역이 힙 영역을 침범하면 **스택 오버플로우**, 그 반대는 **힙 오버플로우**이다.  

**스레드**

스레드(Thread)는 프로세스에서 실제로 실행되는 흐름의 단위로 각 프로세스는 한 개 이상의 스레드를 가진다. 스레드는 프로세스의 메모리 공간을 이용하고 그 중 스택 영역을 할당받는다. 전역 변수를 저장하는 힙 영역은 모든 스레드가 공유한다.

### 2.2 PCB

프로세스 제어 블록(Process Control Block, PCB)는 프로세스를 제어하기 위해 프로세스 정보를 저장한다. 프로세스의 현재 상태, 고유 PID, 부모와 자식 프로세스의 PID, 다음 실행할 명령어의 주소 PC(Program Counter), 프로세스 우선순위, 메모리 제한 등의 정보를 저장한다.

### 2.3 프로세스 생성

부모 프로세스에서 **fork()** 함수를 호출하면 부모 프로세스는 자식 프로세스의 PID 값을, 자식 프로세스는 0을 반환

![이미지5](https://imgur.com/elgnsbc.png)

### 2.4 프로세스 상태도

모든 프로세스는 CPU에 의해 생성 및 소멸 과정을 거친다.

1. 생성 : PCB를 가지고 있지만, OS로부터 승인 대기
2. 준비 : OS로부터 승인을 받은 후 준비 큐에서 CPU 할당 대기
3. 실행 : 프로세스가 CPU를 할당받아 실행
4. 대기 : 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 대기
5. 종료 : 프로세스 실행 종료

![이미지6](https://imgur.com/7C72xpZ.png)

### 2.5 멀티 프로세스와 멀티 스레드

- 동시성
  : 하나의 코어에서 여러 작업을 번갈아 가면서 처리하는 방식, CPU는 하나의 작업만 처리할 수 있어서 여러 작업을 번갈아 처리하는데 이를 컨텍스트 스위칭이라고 함

- 병렬성
  : CPU가 여러 코어를 사용해 여러 작업을 동시에 처리하는 방식

**멀티 프로세스**

응용 프로그램 하나를 여러 프로세스로 구성하는 것이다. 각 프로세스는 독립적인 메모리를 할당 받으며 공유할 자원이 있다면 IPC(Inter Process Communication)를 통해 프로세스 간 자원을 공유할 수 있다. IPC를 이용한 메모리 참조는 공유할 메모리를 직접 참조하는 것보다 비효율적이다.

- 장점 : 한 프로세스가 죽어도 다른 프로세스에 영향이 없음
- 단점 : 시간과 메모리 공간을 많이 사용하고(오버헤드) 여러 프로세스를 처리하려면 컨텍스트 스위칭이 필요

**멀티 스레드**

스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것이다. 스레드 간에는 힙, 데이터, 코드 영역을 공유한다.

- 장점 : 컨텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC를 사용하지 않는다.
- 단점 : 스택 영역을 다른 스레드와 함께 공유하기 때문에 공유 자원에 대한 동기화가 필수적이다. 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향을 미칠 수 있다.

### 2.6 컨텍스트 스위칭

컨텍스트 스위칭(Context Switching)은 멀티 프로세스 환경에서 CPU가 처리 중인 프로세스 정보를 바꾸는 것이다. CPU는 하나의 프로세스만 처리 가능하기 때문에 멀티 프로세스를 처리하려면 CPU 스케쥴러에 의해 인터럽트가 발생하며 컨텍스트 스위칭이 일어난다.  

- 인터럽트
  : 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것
- 컨텍스트
  : CPU가 처리하는 프로세스의 정보를 의미

CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유는 PCB에 PC와 스택 포인터 값이 저장되어 있기 때문이다.

- 프로그램 카운터(Program Counter, PC)
  : 프로세스가 이어서 처리해야 하는 명령어의 주소
- 스택 포인터(Stack Pointer)
  : 스택 영역에서 데이터가 채워진 가장 높은 주소 값

![이미지7](https://imgur.com/Ejdt29D.png)

### 2.7 프로세스 동기화

- 경쟁 상태
  : 공유 자원에 동시에 접근해 경쟁하는 상태
- 임계 영역
  : 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역
- 프로세스 동기화
  : 임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 동기화해야 함

**임계 영역에 여러 동시 접근을 방지하는 조건**

- 상호 배제 기법
  : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없음
- 진행
  : 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행
- 한정된 대기
  : 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음

**뮤텍스**

뮤텍스(Mutex)란 락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법이다. 임계 영역에 접근한 프로세스가 임계 영역에 락을 거는 것을 락킹 알고리즘이라고 한다.

- 스핀락
  : 임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 락이 풀렸는지 루프를 돌며 대기하는 것

**세마포어**

세마포어(Semaphore)란 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법이다.

### 2.8 교착 상태

상호 배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태

**교착 상태 필요충분조건**

교착 상태(Dead Lock)를 예방하기 위해서 아래 조건 중 한 가지 이상 제거하면 된다.

1. 상호배제(Mutual Exclusion)
   : 하나의 공유 자원에 하나의 프로세스만 접근할 수 있음
2. 점유와 대기(Hold and Wait)
   : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 프로세스에서 사용 중인 자원을 점유하기 위해 대기
3. 비선점(No Preemption)
   : 다른 프로세스에 할당된 자원을 뺏을 수 없음
4. 순환 대기(Circular Wait)
   : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구

### 2.9 스레드 안전

스레드 안전은 멀티 스레드 환경에서 하나의 변수, 함수, 객체에 여러 개의 스레드가 동시에 접근해도 문제가 없는 상태이다. 한 변수에 2개 이상의 스레드가 접근하면 잘못된 결과가 초래될 가능성이 있다.

### 2.10 IPC

IPC(Inter Process Communication)은 프로세스 간 공유하는 자원이 있을 경우 IPC를 이용한다.

### 2.11 좀비 프로세스와 고아 프로세스

자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우 남겨진 자식 프로세스를 좀비 프로세스라고 한다. 고아 프로세스는 자식 프로세스보다 부모 프로세스가 먼저 종료되는 경우 자식 프로세스이다.

## 3. 스케줄링

---

스케줄링(Scheduling)은 멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하기 위해 사용한다.  

### 3.1 스케줄링 단계

- 장기 스케줄링
  : 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절한다. 잡 스케줄링 또는 승인 스케줄링이라고 한다.

- 중기 스케줄링
  : 메모리에 로드된 프로세스 수를 동적으로 조절한다. 메모리에 프로세스가 많이 로드되면 **스왑 아웃**해서 일부 프로세스를 통째로 저장하고 스왑 아웃된 프로세스는 중단 상태가 된다.

  ![이미지8](https://imgur.com/cmNlucH.png)

- 단기 스케줄링
  : 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정한다. 즉, 어떤 프로세스를 디스패치할지 결정하는데 이를 **CPU 스케줄링**이라고 한다.

### 3.2 스케줄링 알고리즘

CPU 스케줄러가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는데 사용된다.

**비선점형 스케줄링**

실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없다.

- FCFS 스케줄링(First Come First Served)
  : 준비 큐에 먼저 들어온 프로세스가 우선순위를 가짐
- SJF 스케줄링(Shortest Job First)
  : 실행 시간이 짧은 프로세스가 우선순위를 가짐

**선점형 스케줄링**

스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있다.

- RP 스케줄링(Round Robin)
  : 비선점형 스케줄링과 달리 프로세스간 우선순위가 없다. 모든 프로세스를 순서대로 일정 시간동안 실행하며, 일정 시간을 초과하면 다른 프로세스를 실행한다.
- SRTF 스케줄링(Shortest Remaining Time First)
  : 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행하는 알고리즘이다. 한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행 시간이 더 짧은 프로세스가 CPU를 점유하게 된다. 평균 대기 시간이 가장 짧지만, 수행 시간이 긴 프로세스는 기아 상태가 되기 쉽다.
- 멀티 레벨 스케줄링(Multi Level)
  : 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘이다. 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용할 수 있다.

## 4. 메모리 관리 전략

---

### 4.1 논리 메모리와 물리 메모리

CPU가 프로세스를 처리할 때 보는 주소 값과 실제 메모리의 주소 값은 다르다. 논리(가상) 메모리 영역은 프로세스가 보는 메모리 영역이고 논리(가상) 주소는 CPU가 프로세스를 실행하며 보는 값이다. 물리 메모리 영역은 실제 사용되는 메모리 영역이고 물리 주소는 실제 메모리에서 사용되는 주소이다.

- 메모리 관리 장치(Memory Management Unit, MMU)
  : CPU가 프로세스를 실행할 때 사용하는 주소 값과 실제 주소 값이 다르기 때문에 논리 주소를 물리 주소로 변환 해주는 하드웨어 장치

  ![이미지9](https://imgur.com/EWd1WsW.png)

### 4.2 연속 메모리 할당

**고정 분할 방식**

메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식으로 메모리에 올릴 수 있는 프로세스 수와 각 프로세스의 크기가 제한적이며 단편화 문제가 발생할 수 있다.

**가변 분할 방식**

할당할 프로세스의 크기에 따라 공간을 분할하는 방식이다.

- 최초 적합(first-fit)
  : 가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식
- 최적 적합(best-fit)
  : 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식
- 최악 적합(worst-fit)
  : 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식

### 4.3 비연속 메모리 할당

**페이징**

프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 **페이지**와 **프레임**으로 나눈다.

- 페이지 테이블
  : 페이지와 프레임을 매핑하는 곳으로 페이지 테이블은 각 프로세스의 PCB에 저장된다.

  ![이미지10](https://imgur.com/jwa1zPq.png)

**세그먼테이션**

프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분리해 메모리를 할당한다.

- 세그먼테이션 테이블
  : 세그먼트의 논리 주소를 물리 주소로 매핑하는 곳

  ![이미지11](https://imgur.com/S0ujpW6.png)

## 5. 가상 메모리

---

가상 메모리(Virtual Memory)는 프로세스의 일부만 메모리에 로드하고 나머지는 디스크에 둔 상태로 프로세스를 실행하는 방식이다.

- 메모리 크기에 대한 제약을 덜 받을 수 있음
- 동시에 많은 프로그램을 실행하므로 CPU 이용률과 처리율을 높일 수 있음
- 필요한 영역만 메모리에 로드해 스와핑 횟수를 줄여서 프로그램 실행 속도를 높일 수 있음

![이미지12](https://imgur.com/gJpfGUg.png)

### 5.1 요구 페이징

프로세스에서 필요한 페이지만 메모리에 로드하는 방식이다. 필요한 페이지를 물리 메모리에 로드하고, 필요하지 않은 페이지는 디스크에 저장한다.

- 페이지 폴트
  : 프로그램을 실행하다가 물리 메모리에서 필요한 페이지가 없을 때 디스크에서 필요한 페이지를 스왑-인한다.

- 페이지 테이블
  : 페이지에 해당 메모리 영역이 물리 메모리에 있는지 페이지 테이블로 파악 가능하다.

![이미지13](https://imgur.com/BhxHcZ6.png)

### 5.2 스레싱

동시에 일정 수 이상의 프로그램을 실행했을 때 오히려 CPU 이용률이 떨어지는 상황이다. 다중 프로그램 정도가 일정 이상 수준에서 잦은 페이징으로 인해 실질적인 CPU 이용이 떨어진다.

![이미지14](https://imgur.com/WCJsfzQ.png)

## 6. 캐시 메모리

---

### 6.1 캐시 메모리와 지역성

캐시 메모리는 CPU와 메인 메모리 간에 데이터 접근 시 속도 차이를 줄이기 위해 사용된다. 지역성은 CPU가 자주 참조하는 데이터가 고르게 분포되지 않고 특정 부분에 몰려 있는 것을 말한다.

- 시간 지역성 : 최근 참조한 내용을 다시 참조할 가능성이 높음
- 공간 지역성 : 실제 참조한 주소 근처의 내용을 참조할 가능성이 높음

### 6.2 캐시 메모리의 매핑 방식

- 직접 매핑
  : 메인 메모리를 일정한 크기로 나누고 각 영역을 캐시 메모리에 매핑하는 방식
- 연관 매핑
  : 메모리 영역을 캐시 메모리에 규칙 없이 매핑하는 방식
- 집합 연관 매핑
  : 직접 매핑과 연관 매핑을 결합해 단점을 보완한 방식
