---
title: "[자료구조] Vector"
date: 2025-10-03
categories: [Computer Science, Data Structure]
tags: [Computer Science, Data Structure, Unity, Unreal, vector, 컴퓨터공학, 자료구조, 유니티, 벡터]
series: "[자료구조]"
series_order : 2
pin: false
math: true
image:
  path: https://imgur.com/yTRCTI0.jpg
---

{% raw %}

## Vector의 특징

---

- 가장 큰 장점은 동적 배열로, 크기가 자동으로 늘어나는 가변적으로 변하는 배열
- 속도는 배열에 비해 떨어지지만 메모리 상에서 연속적으로 배치 되어있어 메모리를 효율적으로 관리할 수 있음
- 대신 원소가 추가, 제거 될 때 메모리 재할당이 발생할 수 있고 부하가 발생함
- 생성시 메모리 heap 영역에 할당됨

## Vector의 선언

---

- `#include <vector>`
<br>
- `vector<Type> Var(constexpr int N);` : 원소를 N만큼 생성 후 기본값으로 초기화
- `vector<Type> Var = { Var1, Var2, Var3, ... };` : 오른값으로 벡터를 생성
- `vector<Type> Var[] = { Var1, Var2, Var3, ... };` : 벡터 배열 선언 및 초기화(열은 고정, 행은 가변)
- `vector<vector<Type>> Var;` : 2차원 벡터 생성(열과 행 모두 가변)
- `vector<Type> Var.assign(Range, InitValue);` : 벡터 Range 범위 내에서 InitValue 값으로 초기화
- `vector<Type> Var(iter_start, iter_end);` : 다른 벡터의 [start, end) 범위를 복사하여 생성

```cpp
#include <vector>
using namespace std;

int main()
{
    vector<int> v1;

    vector<int>v2(4);

    vector<int>v3 = { 1, 2, 3 };

    vector<int>v4[] = {{1, 2}, {3, 4}};

    vector<vector<int>> v5;

    vector<int> v6 = { 1, 2, 3, 4, 5 };
    v6.assign(5, 10); // { 10, 10, 10, 10, 10 }
}
```

## Vector의 Iterator

---

- `v.begin()` : 벡터의 시작 점의 주소 값 반환
- `v.end()` : 벡터의 끝 지점 + 1의 주소를 반환
- `v.rbegin()` : 벡터의 끝 지점을 시작 점으로 반환
- `v.rend()` : 벡터의 시작 - 1의 주소를 반환

![이미지1](https://imgur.com/ztO0SAL.png)

## Vector의 원소 접근

---

- `v.at(i)` : i번째 원소 접근(범위 검사 함)
- `v[i]`(operator []) : i번째 원소 접근(범위 검사 안함)
- `v.front()` : 벡터의 첫 번째 원소 접근
- `v.back()` : 벡터의 마지막 원소 접근

## 기본 멤버 함수

---

- `push_back()` : 마지막에 원소 추가
- `pop_back()` : 마지막 원소 제거
- `insert(Pos, Value)` : 해당 위치에 원소 삽입
- `emplace(Pos, Value)` : 해당 위치에 원소 삽입(move semantics로 복사 생성자 호출 안함)
- `emplace_back()` : 마지막에 원소 추가(move semantics로 복사 생성자 호출 안함)
- `erase(Pos), erase(start, end)` : 해당 위치 또는 범위의 원소 제거
- `clear()` : 모든 원소를 제거(size = 0)
- `swap(vector)` : 해당 벡터와 스왑
- `empty()` : 벡터가 비어있으면 `true`, 아니면 `false`를 반환
- `size()` : 벡터의 크기를 반환
- `resize()` : size를 재설정(범위 초과 시 0으로 초기화)
- `capacity()` : heap에 할당된 벡터의 실제 크기(최대 크기)를 반환
- `reserve()` : capacity를 재설정
- `max_size()` : 시스템 상에서 만들어질 수 있는 최대 크기 반환
- `shrink_to_fit()` : capacity를 size에 맞춤

```cpp
#include <vector>
using namespace std;

int main()
{
    vector<int> v;

    v.push_back(10);
    v.push_back(20);        //v = { 10, 20 }

    v.insert(v.begin() + 1, 100);     // v = { 10, 100, 20 }

    v.pop_back();        // v = { 10, 100 }

    v.emplace_back(1); //v = { 10, 100, 1 }
    v.emplace_back(2);    //v = { 10, 100, 1, 2 }
    v.emplace(v.begin() + 2, -50);    //v = { 1, 100, -50, 1, 2 }

    v.erase(v.begin() + 1); // v = { 1, -50, 1, 2 }
    v.resize(6);    // v = { 1, -50, 1, 2, 0, 0 }
    v.clear();    // v = empty()
}
```
```cpp
vector<int>v = { 1, 2, 3, 4 };

cout << v.size() << endl;    //output : 4
cout << v.capacity() << endl; //output : 10 (컴파일 환경에 따라 달라질 수 있음)

v.reserve(6);
cout << v.capacity() << endl; //output : 6
cout << v.max_size() << endl; //output : 1073741823(시스템 성능에 따라 달라질 수 있음)

v.shrink_to_fit();
cout << v.capacity() << endl; //output : 4

cout << v.empty() << endl; //output : false
v.clear();
cout << v.empty() << endl; //output : true
```

## Vector의 원소 추가 시 복사 생성자

---

- `push_back()`은 과정에서 복사 생성자를 호출하고 `insert()`의 경우 모든 값들을 새로운 메모리에 복사한 후 해당 자리에 값을 삽입하므로 오버헤드가 커지게 되고 성능 저하를 야기
- 복사 생성자를 호출하지 않으려면 `emplace()`와 `emplace_back()`을 사용
    → 내부적으로 생성자를 호출해주고 move semantics를 지원하여 복사생성자를 호출하지 않음

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class A 
{
    private:
        int num;
        string name;
    public:
        A(int i, std::string s) : num(i), name(s) {}
};

int main(void) 
{
    vector<A> v;
    A a(1, "Kim");

    v.push_back(1, "hi");        // Error !! -> 생성자 호출 X
    v.emplace_back(1, "hi");  // OK !!

    return 0;
}
```

## Vector의 size와 capacity

---

- size는 생성된 크기이고 capacity는 최대 할당 크기
- size가 capacity를 초과해버리면 reallocate(재할당)이 발생
    → 이때 모든 값들을 새로운 메모리에 복사(복사 생성자 호출) 후 기존 벡터를 파괴
- `reserve()` 함수를 이용해 capacity의 크기를 충분히 확보하여 사전에 방지
- 다만 capacity를 너무 크게 잡으면 불필요한 메모리를 잡아먹음
- `shrink_to_fit()`을 이용하면 capacity의 크기를 알맞게 조정해줄 수 있음

![이미지2](https://imgur.com/hIcWWEi.png)

## Vector의 Clear

---

- `clear()`로 값들을 지우게 되면 원소는 없어지지만 capacity는 그대로
- 잉여 공간을 지우려면 `swap()`을 이용

```cpp
vector<int> v = { 1, 2, 3, 4};
v.clear();
cout << v.capacity() << endl;    //output : 10

vector<int>().swap(v);
cout << v.capacity() << endl;    //output : 0
```
{% endraw%}
