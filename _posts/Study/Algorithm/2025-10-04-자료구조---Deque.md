---
title: 자료구조 - Deque
date: 2025-10-04
categories: [Computer Science, Data Structure]
tags: [Computer Science, Data Structure, Unity, Unreal, deque, 컴퓨터공학, 자료구조, 유니티, 덱]
pin: false
math: true
image:
  path: https://imgur.com/yTRCTI0.jpg
---

## Deque의 특징

---

- 배열 기반 시퀀스 컨테이너로 vector의 단점을 보완하기 위해 만들어짐
- 여러 개의 메모리 블록을 할당하고 하나의 블록처럼 다루고, capacity가 부족할 때마다 일정한 크기의 새로운 메모리 블록을 할당
- 데이터의 삽입과 삭제가 front와 back에서 이루어짐

## Deque의 선언

---

- `#include <deque>`
<br>
- `deque<Type> Var;` : 선언된 타입을 담는 덱 생성
- `deque<Type> Var(N);` : 선언된 타입의 기본 값으로 초기화된 N개의 원소를 담은 덱 생성
- `deque<Type> Var(N, M);` : 선언된 타입의 M 값으로 초기화된 N개의 원소를 담은 덱 생성

## Deque의 Iterator

---

- `dq.begin()` : 덱의 시작 점의 주소 값 반환
- `dq.end()` : 덱의 끝 지점 + 1의 주소를 반환
- `dq.rbegin()` : 덱의 끝 지점을 시작 점으로 반환
- `dq.rend()` : 덱의 시작 - 1의 주소를 반환

## Deque의 원소 접근

---

- `dq.at(i)` : i번째 원소 접근(범위 검사 함)
- `dq[i]`(operator []) : i번째 원소 접근(범위 검사 안함)
- `dq.front()` : 덱의 첫 번째 원소 접근
- `dq.back()` : 덱의 마지막 원소 접근

## 기본 멤버 함수

---

- `assign(N, M)` : M의 값으로 N개 원소 할당
- `push_front()` : 첫 번째에 원소 추가
- `push_back()` : 마지막에 원소 추가
- `pop_front()` : 첫 번째 원소 제거
- `pop_back()` : 마지막 원소 제거
- `insert(Pos, Value)`, `insert(Pos, N, Value)` : 해당 위치에 원소 삽입하거나 N개의 원소를 추가
- `erase(Pos)` : 해당 위치의 원소를 제거하고 제거한 원소 다음의 주소 값을 반환
- `clear()` : 모든 원소를 제거(size = 0)
- `empty()` : 비어있으면 `true`, 아니면 `false`를 반환
- `size()` : 크기를 반환
- `resize()` : size를 재설정(범위 초과 시 0으로 초기화)

```cpp
#include <iostream>
#include <deque>
 
using namespace std;
 
int main() {
    deque<int> dq;
    for(int i=0; i<5; i++)
        dq.push_back((i+1) *10);
 
    deque<int>::iterator iter;
 
    cout << "[Default] : " ;
    for(iter = dq.begin(); iter != dq.end() ; iter++)
        cout << *iter << " ";
    cout << endl;
 
    cout << "[Test1] push_front & end : " ;
 
    dq.push_front(1);
    dq.push_front(2);
    dq.push_back(100);
    dq.push_back(200);
    
    for(iter = dq.begin(); iter != dq.end() ; iter++)
        cout << *iter << " ";
    cout << endl ;
    
    cout << "[Test2] reverse_iterator : ";
    
    deque<int>::reverse_iterator rIter;
    
    for(rIter = dq.rbegin(); rIter != dq.rend() ; rIter++)
        cout << *rIter << " ";
    cout << endl ;
    
    dq.clear();
    
    dq.push_front("Dok2");
    dq.push_back("ZICO");
    dq.push_front("Tiger_JK");
 
    cout << "[Default]" << endl;
    deque<string>::iterator iter;
    for(iter = dq.begin(); iter!= dq.end() ; iter++)
        cout << *iter << " " ;
    cout << endl;
 
    cout << "[Test3] insert(conIter ++ 두번, 2, INSERT)"<<endl;
    deque<string>::const_iterator conIter = dq.begin();
    conIter+=2;
    dq.insert(conIter, 2, "INSERT");
    for(iter = dq.begin(); iter!= dq.end() ; iter++)
        cout << *iter << " " ;
    cout << endl;
 
    cout << "[Test4] dq.end() 의 전전 erase, erase" << endl;
    conIter = dq.end();
    conIter--;
    conIter--;
 
    dq.erase(conIter);
    for(iter = dq.begin(); iter!= dq.end() ; iter++)
        cout << *iter << " " ;
    cout << endl;
 
    dq.erase(conIter);
    for(iter = dq.begin(); iter!= dq.end() ; iter++)
        cout << *iter << " " ;
    cout << endl;
 
    cout << "[Test5-1] dq.at(i) : " ;
    deque<string>::size_type i;
    for(i=0 ; i<dq.size() ; i++)
        cout << dq.at(i) << " " ;
    cout << endl;
 
    cout << "[Test5-2]  dq[i]  : " ;
    for(i=0 ; i<dq.size() ; i++)
        cout << dq[i] << " " ;
    cout << endl;
    
    return 0;
}
```
