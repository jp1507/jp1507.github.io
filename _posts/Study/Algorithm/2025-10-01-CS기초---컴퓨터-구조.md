---
title: CS기초 - 컴퓨터 구조
date: 2025-10-01
categories: [Computer Science, Fundamentals]
tags: [Computer Science, algorithm, Unity, Unreal, structure of computer, 컴퓨터공학, 알고리즘, 유니티, 언리얼, 컴퓨터 구조]
series: "CS 기초"
series_order : 1
pin: false
math: true
image:
  path: https://imgur.com/QCj6GGe.jpg
---

## 1. 폰 노이만 구조

---

현대 대부분의 컴퓨터는 1945년 폰 노이만이 설계한 폰 노이만 구조로 되어있다. 폰 노이만 구조의 핵심은 CPU와 메모리를 분리하여 명령어를 따로 저장하는 **프로그램 내장 방식**이다.  연산 작업을 프로그램 메모리에 순서대로 저장한 후 해당 연산 작업이 필요하면 저장해놓은 프로그램을 찾아 입력값과 함께 CPU에 전달하여 작업을 진행한다.

![이미지1](https://imgur.com/sql0Y9O.jpg)

- 폰 노이만 구조 핵심 특징
  1. 프로그램 내장 방식 : 프로그램과 데이터를 같은 메모리에 저장
  2. 순차적 실행 : 명령어를 하나씩 순서대로 실행
  3. 이진 시스템 : 모든 정보를 0과 1로 표현

폰 노이만 구조의 단점으로는 **병목 현상(Bottle-neck)**이 있다. 메모리에서 저장하고, 꺼내쓰는 과정에서 CPU와 메모리 사이 명령들을 전송하는 속도가 느린 것과 더불어 메모리 안에서 원하는 프로그램을 찾는 작업도 느리다. 즉, 실제 연산 도중에 CPU가 아무 작업도 하지 않고 유휴 상태인 병목 현상이 쉽게 발생하는 문제가 있다.

## 2. CPU(Central Processing Unit)

---

CPU는 컴퓨터의 가장 핵심적인 장치이다. CPU 명령 사이클에 다라 메모리(RAM)에서 명령어를 읽어 해석하고 수행하는 작업을 한다. 한 컴퓨터에 2개 이상의 CPU를 장착할 수 있으며, 이를 **멀티 프로세서**라고 한다.

### 2.1 Clock과 Hz

- Clock
  : CPU 내부에서 시간의 흐름을 측정하고, CPU가 일정한 속도로 동작하기 위해 일정한 간격으로 공급되는 전기적 펄스이다. Clock 한 번에 한 개의 명령어를 처리한다.
- Hz
  : 주파수를 측정하는 단위로, 초당 사이클의 수를 나타낸다.

전기적 신호가 초당 CPU에 공급되는 횟수라는 개념에서 Hz라는 단위로 CPU의 속도를 표현한다. Hz가 높을수록 CPU는 더 많은 연산을 빠르게 수행할 수 있다.

### 2.2 CPU의 구성 요소

**Core**

CPU 역할을 수행하는 블록의 물리적인 단위로, 한 개의 CPU 칩 안에 하나 이상의 코어가 포함된다.

**Cache Memory**

자주 사용되는 데이터와 명령어를 저장하고, CPU가 메모리에 접근할 때 캐시에서 데이터를 먼저 검색해 성능을 향상시킨다.

- L1 Cache
  : 일반적으로 코어 안에 내장되어 데이터 사용/참조에 가장 먼저 사용됨. 보통 8~64KB 정도 용량으로 CPU가 가장 빠르게 접근하며, L1 캐시에서 데이터를 찾지 못하면 L2 캐시를 참조함
- L2 Cache
  : L2 캐시는 L1와 비슷하지만 상대적으로 속도가 느리고, 64KB~4MB의 용량으로 상대적으로 많은 용량을 저장할 수 있음
- L3 Cache
  : L3 캐시도 동일 원리로 작동하지만, 웬만한 프로세서에서는 L3 캐시 메모리를 사용하지 않음(L2 캐시로 충분함)

- Cache Hit : 캐시 메모리 내 찾는 데이터가 존재
- Cache Miss : 캐시 메모리 내 찾는 데이터가 부존재
- 시간적 지역성 : 최근 사용된 데이터가 다시 사용될 가능성이 높음
- 공간적 지역성 : 최근 사용된 데이터 근처에 있는 데이터가 사용될 가능성이 높음

용량이 매우 작고 많은 비용이 들기 때문에 CPU가 자주 사용할 만한 데이터를 잘 예측해서 저장해야함 → Cache Miss를 줄이고 Cache Hit rate를 늘려야함  
시간적, 공간적 지역성을 가진 데이터를 저장하면 Cache Hit rate를 늘릴 수 있음

**Bus Interface**

메모리나 다른 하드웨어와의 데이터 전송 통로

**Clock Generator**

Clock 신호를 생성한다.

### 2.3 코어의 구성 요소

**ALU(Arithmetic Logic Unit)**

여러 산술 및 논리 연산을 처리한다.

  1. GR을 통해 피연산자를 입력받음
  2. CU로부터 명령을 전달 받음
  3. 연산을 수행한 결과를 다시 GR과 Flag register에 저장

**제어 장치(Control Unit, CU)**

전기적 제어 신호를 발생시켜 명령어의 순서 및 수행, 하드웨어 구성 요소들의 동작을 제어한다.

- PC와 MAR에 저장된 주소를 바탕으로 메모리에서 명령어를 가져옴(Fetch)
- 가져온 명령어는 IR에 저장되고, 그 명령어를 해석(Decode)
- 해석한 명령어에 따라 각 구성 요소에 적절한 제어 신호를 보내 어떻게 상호작용해야 하는지 지시
- Clock 신호를 바탕으로 각 구성 요소의 타이밍을 맞추고 동기화
  
제어 신호의 역할

- 데이터 흐름 제어 : 데이터의 이동 경로 제어
- 연산 제어 : ALU가 어떤 연산을 수행할지 지시
- 명령어 순서 제어 : 프로그램의 흐름 제어
- 입출력 장 치 제어 : 입출력 장치와의 상호작용을 관리

**Register**

CPU 내부에 가장 빠른 저장 장치로, 프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장된다. CPU는 연산을 수행하기 위해 데이터를 자주 읽고 써야하는데 CPU와 메모리 간 전송 속도가 CPU와 레지스터 간 속도보다 느리기 때문에 메모리와 직접 데이터를 주고 받지 않고 레지스터를 사용한다.

32 Bit / 64Bit 컴퓨터에서 비트는 레지스터의 비트 수를 가리킨다.

  1. PC(Program Counter)

     - 메모리에서 읽어 들일 명령어의 주소를 저장하는 레지스터
     - CPU 명령어를 실행할 때마다 PC가 자동적으로 증가하여 다음 명령어의 위치를 가리킴
     - 분기 명령어나 함수 호출 같은 명령어가 수행되면 그에 따라 PC가 변경될 수 있음
     - CPU가 프로그램을 순차적으로 실행하는데 굉장히 중요한 역할을 함

  2. 명령어 레지스터(Instruction Register, IR)

     - 현재 CPU가 해석하고 있는 명령어를 저장
     - 명령어가 메모리에서 읽히면 이 레지스터에 저장되고, CPU는 이 레지스터에서 읽고 해석하며 실행함

  3. 메모리 주소 레지스터(Memory Address Register, MAR)

     - 메모리 주소를 저장
     - 메모리와의 안정적이고 정확한 통신에 사용하기 위한 목적으로 저장

    1. CPU가 메모리의 특정 위치에서 데이터를 읽으려고 함
    2. 메모리가 저장된 주소는 먼저 MAR에 저장
    3. 다시 MAR을 사용하여 해당 위치를 찾음

  4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR)

     - 메모리와 주고받을 데이터와 명령어를 저장함

       1. CPU가 메모리에서 데이터를 읽으려고 함
       2. 데이터는 먼저 MBR에 저장
       3. CPU는 MBR을 통해 데이터를 가져옴

  5. 일반 목적 레지스터(General Purpose Register, GR)

     - 데이터 임시 저장과 연산을 위한 레지스터
     - 누산기(Accumulator)의 역할

  6. 플래그 레지스터(Flag Register)

     - CPU가 최근에 수행한 연산에 대한 정보와 CPU의 현재 상태를 나타내는 플래그를 저장함
       - 복잡한 연산을 수행하거나 프로그램 흐름을 제어
       - 연산 결과가 양수, 음수인지 오버플로우가 발생했는지 등
     - CPU의 상태를 나타내는 용도로 **Status Register**가 따로 있을 수 있음
    
  7. 스택 포인터(Stack Pointer)

     - 스택의 가장 위를 가리키는 레지스터로, 채워져있을 만큼의 가장 상단을 가리킴

### 2.4 현재 CPU의 고급 기능

- 파이프라이닝(Pipelining)
  : 여러 명령어를 동시에 처리하여 성능 향상

- 분기 예측(Branch Prediction)
  : 조건문의 결과를 미리 예측하여 파이프라인 효율성 증대

- 멀티 코어(Multi-Core)
  : 여러 개의 CPU 코어를 사용해 명령을 병렬 처리

## 3. 메모리(Memory)

---

메모리는 CPU가 처리할 데이터나 명령어들을 임시로 기억하고 저장될 수 있게 하는 공간이다. 사용자가 어떤 프로그램을 사용할 때, 해당 정보에 빠르게 접근할 수 있게 관련 데이터들을 임시로 기억해서 저장해두는 역할을 한다.

### 3.1 메모리 계층 구조

![이미지2](https://imgur.com/6rc8VjI.png)

메모리 계층 구조는 속도, 용량, 비용 간의 절충 관계를 고려해 필요에 따라 여러 가지 종류로 나타낸 구조이다. 계층 구조에서 위쪽으로 갈 수록 CPU 코어에 가까워지기 때문에 CPU가 메모리에 더 빠르게 접근할 수 있지만, 그 만큼 비용이 크고 저장 용량이 작다.

**메모리 계층 구조의 필요성**

- 자주 쓰이는 데이터는 계속 사용됨(참조의 지역성)
  : 큰 메모리를 사용한다 해도 그 메모리 안에 있는 모든 데이터를 고르게 접근하지 않는다. 자주 쓰이는 데이터는 계속 자주 쓰이고, 자주 쓰이지 않는 데이터는 계속 자주 쓰이지 않으며 자주 쓰이는 데이터는 전체 데이터의 일부이기 때문에 상위 메모리의 용량이 하위 메모리 용량보다 적어도 된다.

- 디코딩(명령어 해독 단계) 속도
  : CPU가 메모리에 접근할 때 컨트롤 신호를 복호화하여 해석해야 하는데 큰 메모리 용량을 사용할 경우 디코딩하는데 더 많은 시간이 소요된다. CPU가 빠르게 접근하기 위해서는 더 작은 메모리를 사용해야한다.

- 경제성
  : 상위 계층 메모리일수록 더 비싸다.

### 3.2 메모리 접근 속도와 용량의 트레이드오프

| 메모리 종류 | 접근 시간 | 용량        | 가격/GB |
| ----------- | --------- | ----------- | ------- |
| 레지스터    | 1ns       | 수십 바이트 | -       |
| L1 캐시     | 1-2ns     | 32KB        | $$$     |
| L2 캐시     | 3-10ns    | 256KB       | $$      |
| L3 캐시     | 10-20ns   | 8MB         | $       |
| RAM         | 50-100ns  | 16GB        | $       |
| SSD         | 10-100μs  | 512GB       | ¢       |
| HDD         | 5-10ms    | 2TB         | ¢       |

### 3.3 메인 메모리 구조

![이미지3](https://imgur.com/iJrLpR4.png)

메인 메모리 내부에는 Code, Data, Heap, Stack의 4개 영역으로 구분된다.

**Code 영역**

코드 영역은 Text 영역으로 불리기도 하며, 우리가 실행하고자 하는 프로그램의 소스코드가 저장되는 영역이다.

- 프로그램이 시작할 때 생성되고 프로그램이 종료될 때 메모리에서 지워진다.
- 프로그램의 소스코드들은 컴파일된 기계어(이진수)로 저장된다.
- 일반적으로 함수가 Code 영역에 해당된다.

**Data 영역**

데이터 영역은 프로그램의 전역 변수와 정적 변수가 저장되는 영역이다.  

- 코드 영역과 마찬가지로 중간에 사라지지 않고 프로그램이 종료될 때까지 메모리에 남아있는다.

**Heap 영역**

힙 영역은 동적으로 할당된 변수가 저장되는 영역이다.

- 사용자가 직접 힙 영역을 통제해서 메모리를 관리할 수 있다.
  - 동적 할당/해제를 통해 직접적으로 관리하며 동적 할당된 변수를 해제하지 않는다면 메모리 누수가 발생해서 문제가 생김
- 힙 영역의 크기는 런타임 시에 결정된다.
- 메모리의 낮은 주소에서 높은 주소로 할당된다.

**Stack 영역**

스택 영역은 지역 변수와 매개변수가 저장되는 영역이다.

- 스택 영역은 함수의 호출과 함께 메모리에 할당되며, 함수 호출이 끝나면 메모리에서 소멸된다.
- 스택 영역의 크기는 컴파일 시 결정된다.
- 스택 영역이 커질수록 힙 영역이 작아지고 힙 영역이 커질수록 스택 영역이 작아진다.
- 힙 영역과 반대로 메모리의 높은 주소에서 낮은 주소로 할당된다.

## 4. 보조기억장치(Storage)

---

보조기억장치는 프로그램과 데이터를 영구적으로 보관할 목적으로 사용되는 입출력 장치이다. 보조기억장치는 컴퓨터와 오프라인으로 연결되어 있으며, 필요할 때 즉시 보조기억장치의 데이터에 접근할 수 없다. 컴퓨터는 입출력 장치를 연결하는 방식으로 보조기억장치에 접근하며, 한번 연결에 적은 양의 데이터를 송수신하는 것이 전체적인 성능 저하의 요인이 된다.  

### 4.1 보조기억장치 종류

**하드디스크**

![이미지4](https://imgur.com/R47Jqvf.png)

- 구성 요소
  - 플래터 : 실질적으로 데이터가 저장되는 동그란 원판이며 0과 1을 기록하기 위해 자기물질로 덮여있음
  - 스핀들 : 플래터를 회전시키는 구성요소
  - 헤드 : 데이터를 읽고 쓰는 역할을 하는 구성요소

- 데이터 저장 방법
  - 트랙 : 플래터를 여러 동심원을 나누었을 때 각각의 원
  - 섹터 : 한 트랙을 여러 조각으로 나누었을 때 하나의 조각
  - 실린더 : 여러 겹의 플래터 상에 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위

- 데이터 접근 과정
  - 탐색 시간 : 헤드가 접근하려는 데이터의 트랙까지 이동
  - 회전 시간 : 헤드가 있는 곳으로 플래터를 회전
  - 전송 시간 : 하드디스크와 컴퓨터 간 데이터를 전송

- 데이터 접근 시간을 줄이는 방법
  - 물리적 : RPM을 높인다.
  - 논리적 : 플래터 혹은 헤드를 조금만 움직여도 접근할 수 있도록 최적의 저장 위치를 결정한다.

**플래시 메모리**

전기적으로 데이터를 지우고 쓸 수 있는 비휘발성 기억 장치이다. 전원 공급이 중단되더라도 메모리칩 안에 정보를 유지할 수 있고, 전기 신호에 따라 제어되기에 데이터 접근이 빠르지만 RAM에 비해 읽기, 쓰기 속도가 매우 느리다. USB, SD 카드, SSD가 모두 플래시 메모리 기반의 보조기억장치이다.

- 원리 및 구조
  - RAM과 비슷하게 cell의 배열로 이루어지며, 각 cell에 1 또는 0 bit 정보가 저장된다. 셀, 페이지, 블록, 플레인, 다이 순으로 큰 단위를 가진다.
  - 페이지는 3개의 상태를 가질 수 있고, 페이지 단위로 삭제가 가능하기 때문에 garbage collection 기능으로 쓰레기값을 정리한다.

**RAID**

주로 하드디스크와 SSD를 사용하는 기술로, 데이터의 안전성, 높은 성능을 위해 여러 개의 물리적 보조기억장치를 하나의 논리적 보조기억장치처럼 사용하는 기술이다.

- RAID의 종류

  ![이미지5](https://imgur.com/UO6qi72.png)

  **RAID 0**

  - 여러 개의 보조기억장치에 데이터를 번갈아가며 저장
  - 이때 마치 줄무늬처럼 분산되어 저장된 데이터를 stripe이라 하며, 분산해 저장하는 것을 striping이라고 함
  - 장점 : 병렬로 연결된 저장 장치가 단일 저장 장치보다 빠름
  - 단점 : 저장된 정보가 안전하지 않음

  **RAID 1**

  - RAID 0의 단점을 보완하고자 등장한 것으로, 복사본을 생성함
  - 거울처럼 완전한 복사본을 만들기에 mirroring이라고 부르며 데이터를 쓸 때 원본과 복사본 두 군데에 모두 쓰는 방식
  - 장점 : 복구가 매우 간단함
  - 단점 : 사용 가능한 용량이 적어지며 비용이 증가

  **RAID 4**

  - RAID 1처럼 완전한 복사본을 만드는 대신, 오류를 검출하고 복구하기 위한 정보를 저장한 장치를 둠
  - 이 정보를 parity bit라고 하며 패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고 복구함
  - 장점 : RAID 1보다 적은 용량으로 데이터를 안전하게 보관
  - 단점 : 새로운 데이터가 저장될 때마다 패리티 저장 장치에 병목 현상이 발생

  **RAID 5**

  - RAID 4의 패리티 병목 현상을 해소하는 방식
  - 패리티 정보를 각 하드 디스크의 한 층으로 분산해 저장

  **RAID 6**

  - RAID 5와 유사하나, 서로 다른 2개의 패리티를 두는 방식
  - 장점 : RAID 5보다 안전하게 데이터 저장
  - 단점 : 쓰기 속도가 RAID 5보다 느림

## 5. 시스템 버스

---

![이미지6](https://imgur.com/1o5Xdc9.png)

시스템 버스는 컴퓨터의 구성 요소(CPU, 기억장치, 입출력 장치) 간의 Data와 신호 교환을 위한 통로이다. 제어 버스, 주소 버스, 데이터 버스라는 하부 버스로 이루어져있다.

### 5.1 시스템 버스의 하부 버스

**제어 버스**

- CPU가 시스템 내의 각종 요소들의 동작을 제어하는데 필요한 신호들을 전달하는 통로
- 제어 선의 개수는 CPU 또는 시스템 구성에 따라 다름
- 읽기/쓰기 동작을 모두 수행하기 때문에 **양방향 버스**

**주소 버스**

- 다른 장치로 주소 정보(기억장치 주소, 입출력 장치 포트 번호)를 전달하는 통로
- 주소 선의 개수와 주소 버스의 폭과 최대 기억장치 용량이 같음
- 주소를 전달만 하기 때문에 **단방향 버스**

**데이터 버스**

- CPU와 다른 장치 사이에서 실질적인 데이터를 전달하는 통로
- 데이터를 주고 받아야 하기 때문에 **양방향 버스**
- 데이터 버스의 폭이 한 번에 전송될 수 있는 데이터의 크기를 결정

### 5.2 CPU와 기억장치간의 통신

![이미지7](https://imgur.com/U0mkCpD.png)

- 적재(Load) : 기억장치 읽기

  1. 주소 버스 : 기억장치에서 읽을 데이터가 저장된 주소 값 전달(CPU → 기억장치)
  2. 제어 버스 : 기억장치 읽기 신호 전달(CPU → 기억장치)
  3. 데이터 버스 : 해당 기억장치에 저장된 데이터 전달(기억장치 → CPU)

- 저장(Store) : 기억장치 쓰기

  1. 주소 버스 : 데이터를 저장할 기억장치의 주소 값 전달(CPU → 기억장치)
  2. 제어 버스 : 기억장치 쓰기 신호 전달(CPU → 기억장치)
  3. 데이터 버스 : 저장할 데이터를 기억장치에 전달(CPU → 기억장치)

### 5.3 CPU와 입출력 장치간의 통신

![이미지8](https://imgur.com/BMBn2Sg.png)

시스템 버스에서 입출력 장치에 직접 연결하지 못하기 때문에 입출력 장치 제어기를 통해 제어 신호를 전달한다.

1. 키보드의 입력이 들어오면 그에 대응되는 데이터가 제어기로 전송되어 데이터 레지스터에 저장
2. 동시에 상태 레지스터에 입력 준비 비트가 설정
3. CPU는 데이터 입력을 원하는 시점이 되면 먼저 상태 레지스터를 읽어 입력 준비 비트를 검사
4. 입력 준비 비트가 설정되어있다면 데이터 레지스터에서 데이터를 읽어오고, 그렇지 않으면 상태 레지스터의 내용을 검사하는 과정 반복

### 5.4 전체 시스템 구성

![이미지9](https://imgur.com/VInLMjL.png)
