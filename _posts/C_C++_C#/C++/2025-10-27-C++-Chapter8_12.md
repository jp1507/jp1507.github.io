---
title: "[C++] Chapter 8.12 친구 함수와 클래스"
date: 2025-10-27 17:14:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 73
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 8. 객체 지향의 기초 : 친구 함수와 클래스

### friend

---

- 클래스에서 어떤 함수나 다른 클래스를 친구로 지정하면 자신의 `private` 멤버들에 자유롭게 접근할 수 있도록 허락

  - 함수를 친구로 지정하는 방법
    - `friend` + 함수 프로토 타입
      ```cpp
      friend int GetInt(int x);
      ```
  - 클래스를 친구로 지정하는 방법
    - `friend class` + 클래스 이름
      ```cpp
      friend class Something
      ```
  - 프로토타입 말고 바디까지 붙여도 되지만 대체로 프로토타입만 지정

### 일반 함수를 친구로 지정하는 경우

---

```cpp
class A
{
private:
    int m_value = 1;
};

void DoSomething(A& a)
{
    cout << a.m_value << endl;    // Error !!!
}
```

- `A` 클래스 멤버 변수 `m_value`는 `private`이기 때문에 `void DoSomething()` 같은 `A` 클래스 바깥의 일반 함수에서 접근할 수 없음

```cpp
class A
{
private:
    int m_value = 1;
    friend void doSomething(A& a);
};

void DoSomething(A& a)
{
    cout << a.m_value << endl;
}
```

- `DoSomething()` 함수를 친구로 지정하면 `A` 클래스의 `private` 멤버들에 접근할 수 있음

**전방 선언**  

```cpp
class A
{
private:
    int m_value = 1;
    friend void DoSomething(A& a, B& b);    // Error !!!
};

class B
{
private:
    int m_value = 1;
    friend void DoSomething(A& a, B& b);  
};

void DoSomething(A& a, B& b)
{
    cout << a.m_value << endl; 
    cout << b.m_value << endl; 
}
```

- `A` 클래스 입장에선 아직 `B` 클래스가 선언되기 전이기 때문에 `DoSomething()` 매개변수인 `B& b`에서 `B`가 누군지 몰라 에러가 발생

```cpp
class B;   // forward declaration

class A
{
private:
    int m_value = 1;
    friend void doSomething(A& a, B& b);
};

class B
{
private:
    int m_value = 1;
    friend void doSomething(A& a, B& b);  
};

void doSomething(A& a, B& b)
{
    cout << a.m_value << endl; 
    cout << b.m_value << endl; 
}
```

- `A` 클래스 선언 위에 선방 선언을 해주면 컴파일러에게 `B` 클래스가 있다는 것을 알려주어 에러가 사라짐

### 클래스를 친구로 지정하는 경우

---

```cpp
class A
{
private:
    int m_value = 1;
    friend class B;
};

class B
{
private:
    int m_value = 1;

    void func_1(A& a)   
    {
        cout << a.m_value << endl;
    }
    void func_2(A& a)   
    {
        a.m_value++;
    }
};
```

- `A` 클래스에서 `B`를 친구로 지정하면 `B` 클래스의 모든 멤버 함수에서 `A`의 `private` 멤버들에 접근할 수 있음

### 다른 클래스의 특정 멤버 함수만 친구로 지정

---

```cpp
class A;

class B
{
private:
    int m_value = 2;
public:
    void DoSomething(A& a);
};

class A 
{
private:
    int m_value = 1;
    friend void B::DoSomething(A &a);
};

void B::DoSomething(A& a)
{
    cout << a.m_value << endl;
}

int main()
{
    A a;
    B b;
    b.DoSomething(a);

    return 0;
}
```

- `A` 클래스에서 `B` 클래스의 멤버 함수 `DoSomething()`만 친구로 지정하면 `B`의 `DoSomething()`에서만 `A` 클래스의 `private` 멤버 변수들에 접근 가능
