---
title: "[C++] Chapter 8.11 정적 멤버 함수"
date: 2025-10-27 16:52:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 72
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 8. 객체 지향의 기초 : 정적 멤버 함수

### static 멤버 함수

---

- `static` 멤버 변수와 같이 객체 이름은 물론이고 클래스 이름만으로 접근 가능
- 객체와 독립적이고 생성과 관련 없음
  - 멤버 변수는 객체 생성으로 메모리를 할당받기 때문에 `static` 멤버 함수 내에서 사용할 수 없음
  - 전역에서 메모리가 할당되는 `static` 멤버 변수는 사용 가능

```cpp
class Something
{
private:
    int noramal_value = 99;
    static int static_value;

public:
    static void Func()
    {
        int a = 1024;
        cout << a << endl;

        // cout << noramal_value << endl; 
        // 일반 멤버 변수는 사용 불가능

        cout << static_value << endl;
    }
};

int Something::static_value = 777;

int main()
{
    Something::Func();
    // 1024 777을 출력

    return 0;
}
```

### static 멤버 함수를 사용하는 이유

---

- 객체 생성 여부와 상관없이 클래스 이름으로 접근하고 싶을 때 사용하지만 주로 `private`인 `static` 멤버 변수에 접근하려고 할 때 사용
  - `static` 멤버 변수는 모든 객체가 사용하고 공유해야하는데 `private`이면 외부에서 직접 접근하고 사용할 수 없음
  - `static` 멤버 함수를 통해 `private static` 멤버 변수에 간접 접근할 수 있도록 구현할 수 있음

```cpp
class Something
{
private:
    static int static_value;
public:
    static int getValue() { return static_value; }
};

int Something::static_value = 777;

int main()
{
    // cout << Something::static_value << endl; Error !!!
    cout << Something::getValue() << endl;   // 777 출력 

    Something s;
    cout << s.getValue() << endl;  // 777 출력 

    return 0;
}
```

### static 멤버 함수는 this 포인터를 사용할 수 없음

---

- `this` 포인터는 객체 자신의 주소를 담고 있기 때문에 객체가 생성되어야만 사용 가능
- `static` 멤버 함수는 객체 생성과 무관하게 어디서든 클래스 이름으로 접근 가능해야하기 때문에 `static` 멤버 함수 내부에서는 `this` 포인터를 사용할 수 없음

```cpp
class Something
{
private:
    static int static_value;
public:
    static int GetValue()
    {
        return this->static_value;    // Error !!!
    }

    int temp()
    {
        return this->static_value;
    }
};
```

**멤버 함수 포인터**  

- 멤버 함수 포인터는 `&클래스이름::함수이름`으로 접근해야 함

```cpp
class Something
{
public:
    int temp() { return 1; }
};

int main()
{
    Something s1;
    Something s2;

    int (Something::*fptr_1)() = s1.temp;   // Error !!!
    int (Something::*fptr_2)() = &Something::temp;
}
```

- 멤버 함수는 객체마다 함수 메모리를 따로 갖는 방식이 아니기 때문
  - 멤버 함수는 어딘가 한 군데에 저장되어 있고 각 객체마다 그 공간을 동일하게 접근하여 각자의 다른 데이터를 사용하는 방식
  - 일반 함수 주소와 다르게 멤버 함수의 주소를 받아야 하고, 속해있는 클래스가 어디인지 알려주어야 함

**함수 포인터로 함수 실행하기 : 일반 멤버 함수**  

```cpp
Something s;

int (Something::*fptr_1)() = &Something::temp;
cout << (s.*fptr_1)() << endl;    // 함수 포인터로 s객체의 temp 실행
```

- 함수 포인터로 일반 멤버 함수를 실행할 때 꼭 `(s.*fptr_1)()`처럼 객체로 접근해주어야 함
  - 함수 포인터는 객체에 종속되어 있는 일반 멤버 함수를 참조하고 있기 때문에 단독으로 호출할 수 없음

**함수 포인터로 함수 실행하기 : static 멤버 함수**  

```cpp
Something s;

int (*fptr_2)() = &Something::temp;
cout << fptr_2() << endl;   // 함수 포인터로 s객체의 temp 실행
```

- `static` 멤버 함수는 객체와 무관하기 때문에 **일반 함수 포인터로 취급**
  - 따라서 포인터 연산시 일반 함수처럼 `int (*fptr_2)()`로 선언
- 일반 함수 포인터처럼 취급되기 때문에 `fptr_2()`처럼 단독 호출할 수 있음
