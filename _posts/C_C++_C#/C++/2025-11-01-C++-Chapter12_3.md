---
title: "[C++] Chapter 12.3 override, final, 공변 반환형"
date: 2025-11-01 13:31:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 105
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 함수 : override, final, 공변 반환형

### override

---

```cpp
class A
{
public:
    virtual void Print(int x) { cout << "A" << endl; }
};

class B : public A
{
public:
    void Print(short x) { cout << "B" << endl; }
}
```

- `Print()` 함수는 가상 함수이므로 자식 클래스에서 오버라이딩 할 것을 권장하는 함수
- `B` 클래스에서 오버라이딩 했지만 매개변수 형식이 틀린 상태
  - 오버라이딩은 리턴 타입, 함수 이름, 매개변수 형식, `const` 유무 모두 같아야 함
- 따라서 오버라이딩 되지 않았다고 판단되어 `A` 클래스의 `Print()`가 호출됨
  - 즉, 오버라이딩이 아닌 오버로딩으로 판단

**Override**  

- 해당 키워드를 붙여주면 오버라이딩된 함수라고 강조하며 오버라이딩이 제대로 안됐을 때 에러를 발생시켜 줌

```cpp
class A
{
public:
    virtual void Print(int x) { cout << "A" << endl; }
};

class B : public A
{
public:
    void Print(short x) override { cout << "B" << endl; }   // Error !!!
}
```

- 매개변수 형식이 틀렸으므로 컴파일 에러를 발생시킴

```cpp
class A
{
public:
    virtual void print(int x) const { cout << "A" << endl; }
};

class B : public A
{
public:
    void print(short x) override { cout << "B" << endl; }   // Error !!!
}
```

- `const`를 붙이지 않아 컴파일 에러 발생

### final

---

- 해딩 키워드를 붙이면 자식 클래스에서 오버라이딩하지 못하도록 막음

```cpp
class A
{
public:
    virtual void Print() { cout << "A" << endl; }
};

class B : public A
{
public:
    void Print() final { cout << "B" << endl; }  
}

class C : public B
{
public:
    void Print()  { cout << "B" << endl; }  // Error !!!
}
```

- `B` 클래스에서 오버라이딩하고 `final` 키워드를 붙였으므로 `C` 클래스에서 오버라이딩을 시도했을 때 에러가 발생함

### 공변 반환형(Covariant Return)

---

- 리턴 타입이 달라도 `this` 포인터를 리턴하는 경우 오버라이딩이 가능

```cpp
class A
{
public:
    void Print() 
    { 
        cout << "A" << endl; 
    }

    virtual A* GetThis() 
    { 
        cout << "A::GetThis()" << endl;
        return this; 
    }
};

class B : public A
{
public:
    void Print() 
    { 
        cout << "B" << endl; 
    }

    virtual B* GetThis() 
    { 
        cout << "B::GetThis()" << endl;
        return this; 
    }
};
```

- 리턴 타입이 `A*`, `B*`으로 다르지만 `B`는 `A`의 자식이므로 `B*` 타입인 `B`의 `this` 포인터는 `A*`의 성질을 가지고 있기 때문에 함수의 리턴 타입이 달라도 오버라이딩이 허용됨

```cpp
int main()
{
    A a;
    B b;

    A &ref = b;
    b.GetThis()->Print();       // B 출력
    ref.GetThis()->Print();     // A 출력

    cout << typeid(b.GetThis()).name() << endl;     // class B * 출력
    cout << typeid(ref.GetThis()).name() << endl;   // class A * 출력

    return 0;
}
```

- 부모-자식 관계에 `this` 포인터를 리턴하므로 오버라이딩되어 `B` 타입의 `GetThis()` 함수가 호출됨
- `B` 타입의 `GetThis()`가 `B*` 타입의 포인터를 리턴하는데 이를 호출한 `ref`가 `A` 타입이기 때문에 `Print()`는 `A` 타입의 `Print()`가 실행
