---
title: "[C++] Chapter 14.3 예외 클래스와 상속"
date: 2025-11-03 14:32:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 124
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 14. 예외처리 : 예외 클래스와 상속

### throw시 기본 자료형 사용

---

```cpp
#include <iostream>

class MyArray
{
private:
    int m_data[5];
public:
    int& operator [](const int& index)
    {
        if (index < 0 || index >= 5) 
            throw -1;

        return m_data[index];
    }
};

void DoSomething()
{
    MyArray my_array;
    
    try
    {
        my_array[100];
    }
    catch (const int& x)
    {
        cerr << "Exception " << x << endl;
    }
}

int main()
{
    DoSomething();
    cout << "main" << endl;
    return 0;
}
```
```text
- 출력 -

Exception -1
```

- `int` 타입과 같은 기본 자료형 데이터를 `throw`하면 어떤 예외인지 표현하는 데에 한계가 있음

### throw시 예외 클래스 객체 사용

---

```cpp
#include <iostream>

class Exception
{
public:
    void Report()
    {
        cerr << "Exception Report" << endl;
    }
};

class MyArray
{
private:
    int m_data[5];
public:
    int& operator [](const int& index)
    {
        if (index < 0 || index >= 5) 
            throw Exception();
        
        return m_data[index];
    }
};

void DoSomething()
{
    MyArray my_array;
    
    try
    {
        my_array[100];
    }
    catch (const int& x)
    {
        cerr << "Exception " << x << endl;
    }
    catch (Exception& e)
    {
        e.Report();
    }
}

int main()
{
    DoSomething();
    cout << "main" << endl;
    return 0;
}
```
```text
- 출력 -

Exception Report
```

- 예외 클래스 `Exception`을 정의해 `throw Exception();`과 같이 익명 객체를 생성한 후 던짐
- `catch(Exception& e)`에서 이를 받아 예외 처리를 실행함

### 예외 클래스의 상속

---

```cpp
#include <iostream>

class Exception
{
public:
    void Report()
    {
        cerr << "Exception Report" << endl;
    }
};

class ArrayException : public Exception
{
public:
    void Report()  // 오버라이딩
    {
        cerr << "Array Exception Report" << endl;
    }
}

class MyArray
{
private:
    int m_data[5];
public:
    int& operator [] (const int& index)
    {
        if (index < 0 || index >= 5) 
            throw ArrayException();

        return m_data[index];
    }
};

void DoSomething()
{
    MyArray my_array;
    
    try
    {
        my_array[100];
    }
    catch (const int& x)
    {
        cerr << "Exception " << x << endl;
    }
    catch (Exception& e)
    {
        e.Report();
    }
}

int main()
{
    DoSomething();
    cout << "main" << endl;
    return 0;
}
```
```text
- 출력 -

Exception Report
```

- **객체 잘림** 현상 때문에 `throw ArrayException` 하더라도 `ArrayException` 클래스가 아닌 `Exception` 클래스의 `Report()` 함수가 실행됨
- `catch(Exception& e)`에서 예외를 받아 실행하는데, 부모인 `Exception` 타입의 참조 변수로 받고 있기 때문에 객체 잘림 현상이 일어나 `Exception`의 `Report()`가 실행됨

**객체 잘림 방지 1 : catch 순서**  

```cpp
throw ArrayException();

...

catch (Exception& e)
{
    e.Report();
}
catch (ArrayException& e)
{
    e.Report();
}
```
```text
- 출력 -

Exception Report
```

- 위와 같이 `Exception` 타입으로 받는 `catch`를 `ArrayException` 타입으로 받는 `catch`보다 위에 두면 객체 잘림 현상이 일어나 `Exception`의 `Report()`가 실행되고, 이미 예외 처리를 했으므로 `catch(ArrayException& e)`는 실행되지 않음

```cpp
throw ArrayException();

...

catch (ArrayException& e)
{
    e.Report();
}
catch (Exception& e)
{
    e.Report();
}
```

- `catch(ArrayException& e)`를 더 위에 배치시키면 객체 잘림 현상 없이 `ArrayException`의 `Report()`를 실행시킬 수 있음

**객체 잘림 방지 2 : virtual 가상 함수**  

- 부모 타입의 참조 변수로 받아도 오버라이딩한 함수를 호출하고 싶으면 가상 함수로 지정

```cpp
#include <iostream>
#include <exception>

class Exception 
{
public:
    virtual void Report() { std::cerr << "Exception Report" << std::endl; }
};

class Exception : public Exception
{
public:
    virtual void Report() override { std::cerr << "Array Exception Report" << std::endl; }
};
```

**catch 내에서 다시 throw하기**  

```cpp
#include <iostream>

class Exception
{
public:
    void Report()
    {
        cerr << "Exception Report" << endl;
    }
};

class ArrayException : public Exception
{
public:
    void Report()
    {
        cerr << "Array Exception Report" << endl;
    }
}

class MyArray
{
private:
    int m_data[5];
public:
    int& operator [](const int& index)
    {
        if (index < 0 || index >= 5) 
            throw ArrayException();

        return m_data[index];
    }
};

void DoSomething()
{
    MyArray my_array;
    
    try
    {
        my_array[100];
    }
    catch (ArrayException& e)
    {
        cout << "DoSomething()" << endl;
        e.Report();
        throw e;
    }
    catch (Exception& e)
    {
        cout << "DoSomething()" << endl;
        e.Report();
    }
}

int main()
{
   try
   {
       DoSomething();
   }
   catch (ArrayException& e)
   {
       cout << "main()" << endl;
       e.Report();
   }
   return 0;
}
```
```text
- 출력 -

DoSomething()
Array Exception Report
main()
Array Exception Report
```

- 예외가 `throw`로 던져지면 알맞는 `catch`를 그 아래 부분에서 찾는 것이 아닌 스택 되감기로 알맞은 `catch`를 찾음
- `DoSomething()` 함수 내에 `throw e`로 다시 예외가 발생하면 호출한 `main()` 함수의 지점으로 돌아가 예외를 처리하며, 그 바로 아래 `catch(Exception& e)`는 실행되지 않음

```cpp
#include <iostream>

class Exception
{
public:
    void Report()
    {
        cerr << "Exception Report" << endl;
    }
};

class ArrayException : public Exception
{
public:
    void Report()
    {
        cerr << "Array Exception Report" << endl;
    }
}
class MyArray
{
private:
    int m_data[5];
public:
    int& operator [](const int& index)
    {
        if (index < 0 || index >= 5) 
            throw ArrayException();

        return m_data[index];
    }
};

void DoSomething()
{
    MyArray my_array;
    
    try
    {
        my_array[100];
    }
    catch (Exception& e)
    {
        cout << "DoSomething()" << endl;
        e.Report();
        throw e;
    }
}

int main()
{
    try
    {
        DoSomething();
    }
    catch (ArrayException& e)
    {
        cout << "main()" << endl;
        e.Report();
    }
    catch (Exception& e)
    {
        cout << "main()" << endl;
        e.Report();
    }
    return 0;
}
```
```text
- 출력 -

DoSomething()
Exception Report
main()
Exception Report
```

- 위 예시에서는 `throw ArrayException();`으로 예외를 발생시켰지만 객체 잘림 현상으로 인해 `Exception` 타입 예외 처리만 실행됨

**객체 잘림 방지 3 : throw;**  

```cpp
catch (Exception& e)
{
    cout << "DoSomething()" << endl;
    e.Report();
    throw;
}
```
```text
- 출력 -

DoSomething()
Exception Report
main()
Array Exception Report
```

- `throw e;`가 아닌 `throw;`만 해주면 원래 객체로 던져짐
