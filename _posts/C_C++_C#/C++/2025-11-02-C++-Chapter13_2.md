---
title: "[C++] Chapter 13.2 클래스 템플릿"
date: 2025-11-02 13:18:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 115
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 13. 템플릿 : 클래스 템플릿

### 일반화와 구체화

---

**일반화**  

```cpp
#include <iostream>

template <typename T>
class MyArray
{
private:
    int m_length;
    T* m_data;
public:
    MyArray(int length)
    {
        m_data = new T[length];
        m_length = length;
    }

    ~MyArray()
    {
        reset();
    }

    void Reset()
    {
        delete [] m_data;
        m_data = nullptr;
        m_length = 0;
    }

    T& operator [](int index)
    {
        assert (index >= 0 && index < m_length);
        return m_data[index];
    }

    int GetLength()
    {
        return m_length;
    }

    void Print()
    {
        for (int i = 0; i < m_length; i++)
            std::cout << m_data[i] << " ";
        std::cout << std::endl;
    }
};
```
{: file="MyArray.h"}

- 여러 자료형으로 일반화할 부분을 `T`로 설정
  - `typename`이 `T`일 필요는 없지만 일반적으로 사용
- 클래스 템플릿은 그 자체로 클래스가 아닌 틀일 뿐임

**구체화**  

```cpp
#include "MyArray.h"

int main()
{
    MyArray<char> my_array(10);

    for (int i = 0; i < my_array.GetLength(); i++)
        my_array[i] = i + 65;

    my_array.Print();

    return 0;
}
```
{: file="main.cpp"}

- `MyArray` 클래스 템플릿을 `char` 타입으로 구체화
  - 이 클래스를 인스턴스화 할 때 메모리를 얼만큼 할당 받을지 결정

### 클래스 템플릿은 헤더 파일만으로 구현

---

- 단순히 헤더 파일과 소스 파일로 분리할 경우 링킹 에러 발생

```cpp
#include <iostream>

template <typename T>
class MyArray
{
    ...

    void Print();
};
```
{: file="MyArray.h"}

```cpp
#include "MyArray.h"

template <typename T>
void MyArray<T>::Print()
{
    for (int i = 0; i < m_length; i++)
        std::cout << m_data[i] << " ";
    std::cout << std::endl;
}
```
{: file="MyArray.cpp"}

```cpp
#include "MyArray.h"

int main()
{
    MyArray<char> my_array(10);

    for (int i = 0; i < my_array.GetLength(); i++)
        my_array[i] = i + 65;

    my_array.Print();       // Error !!!

    return 0;
}
```
{: file="main.cpp"}

- 컴파일에는 문제 없지만 링킹 에러가 발생함
- `MyArray.cpp` 파일을 컴파일 할 때, 어떤 자료형으로 클래스를 구체화 해야하는지 몰라서 `Print()` 함수의 바디가 메모리에 정의가 되지 않았기 때문

**해결 방법1**  

```cpp
#include "MyArray.h"
#include "MyArray.cpp"
```

- 소스 파일도 직접 include 해주는 방법으로 해결할 수 있지만 소스 파일까지 포함하는 일은 프로그램이 커질 시 매우 복잡해지므로 권장되지 않음

**해결 방법2**  

```cpp
#include "MyArray.h"

template <typename T>
void MyArray<T>::Print()
{
    for (int i = 0; i < m_length; i++)
        std::cout << m_data[i] << " ";
    std::cout << std::endl;
}

template void MyArray<char>::Print();
template void MyArray<double>::Print();

template class MyArray<char>;
template class MyArray<double>;
```
{: file="MyArray.cpp"}

- 소스 파일 내부에 특정 자료형들을 구체화해 컴파일 시 메모리가 미리 잡히도록 명시해주는 방법

**해결 방법3**  

```cpp
#include <iostream>

template <typename T>
class MyArray
{
    ...

    void Print()
    {
        for (int i = 0; i < m_length; i++)
            std::cout << m_data[i] << " ";
        std::cout << std::endl;
    }
};
```

- 클래스 템플릿을 구현할 때 헤더 파일 내에 전부 구현하는 방법
- 가장 추천하는 방법
