---
title: "[C++] Chapter 15.4 std::move"
date: 2025-11-04 14:17:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 130
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : std::move

- `include <utility>`
- `std::move(A)`
  - `A`를 R-Value로 변환해 이동 생성자 혹은 이동 대입 연산자가 호출되게끔 함

### std::move 사용 전

---

```cpp
#include <iostream>
using namespace std;

template<typename T>
class AutoPtr
{
public:
    T* m_ptr;
public:
    AutoPtr(T* ptr = nullptr) : m_ptr(ptr) 
    {
        cout << "AutoPtr default constructor" << endl;
    }
    ~AutoPtr()
    {
        cout << "AutoPtr destructor" << endl;

        if (m_ptr != nullptr) delete m_ptr;
    }

    AutoPtr(const AutoPtr& a)
    {
        cout << "AutoPtr copy constructor" << endl;

        m_ptr = new T;  
        *m_ptr = *a.m_ptr;            
    }

    AutoPtr& operator = (const AutoPtr& a)
    {
        cout << "AutoPtr copy assignment" << endl;
        
        if (&a == this)
            return *this;

        if (m_ptr != nullptr) 
            delete m_ptr;

        m_ptr = new T;  
        *m_ptr = *a.m_ptr;
                                                        
        return *this;
    }

    AutoPtr(AutoPtr&& a) : m_ptr(a.m_ptr)
    { 
        a.m_ptr = nullptr;
        cout << "AutoPtr move constructor" << endl;
    }

    AutoPtr& operator = (AutoPtr&& a)
    {
        cout << "AutoPtr move assignment" << endl;

        if (&a == this)
            return *this;
        if (m_ptr != nullptr) 
            delete m_ptr; 
        
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;

        return *this;
    }

    T& operator *() const { return *m_ptr; }
    T* operator ->() const { return m_ptr; }
    bool IsNull() const { return m_ptr == nullptr; }
};
```
{: file="AutoPtr.h"}

```cpp
#include <iostream>

int main()
{
    {
        AutoPtr<Resource> res1(new Resource(10000000));
        cout << res1.m_ptr << endl;

        AutoPtr<Resource> res2 = res1;
        cout << res1.m_ptr << endl;
        cout << res2.m_ptr << endl;
    }
}
```
{: file="main.cpp"}

```text
- 출력 -

Resource length constructed
AutoPtr default constructor
0033F510
AutoPtr copy constructor
Resource default constructed
Resource copy assignment
0033F510
0033F5F0
AutoPtr destructor
Resource destroyed
AutoPtr destructor
Resource destroyed
```

- `AutoPtr<Resource> res2 = res1;`에서 이동 생성자, 복사 생성자 둘 다 구현되어있을 때 동작
  - 객체 생성 과정이므로 복사 생성자나 이동 생성자 중 복사 생성자가 호출됨
    - 복사 대상이 되는 `res1`은 L-Value이므로 R-Value만 받는 이동 생성자는 이를 받을 수 없음
    - 깊은 복사가 이루어짐

### std::move 사용 후

---

- L-Value이지만 이동 생성자를 호출하고 싶다면 `std::move`를 통해 R-Value로 바꿔주면 됨

```cpp
#include <iostream>
#include <utility>

int main()
{
    {
        AutoPtr<Resource> res1(new Resource(10000000));
        cout << res1.m_ptr << endl;

        AutoPtr<Resource> res2 = std::move(res1);
        cout << res1.m_ptr << endl;
        cout << res2.m_ptr << endl;
    }
}
```
{: file="main.cpp"}

```text
- 출력 -

Resource length constructed
AutoPtr default constructor
001FF540
AutoPtr move constructor
00000000
001FF540
AutoPtr destructor
Resource destroyed
AutoPtr destructor
```

- `AutoPtr<Resource> res2 = std::move(res1);`
  - `res1`을 R-Value로 리턴해줌
    - `std::move` 덕에 R-Value가 전달되었기 때문에 이동 생성자가 호출됨
    - 깊은 복사 과정이 없고 소유권 이전과 박탈로 `res1` 포인터는 `nullptr`로 초기화하고 `res1` 포인터가 가리키던 객체를 `res2`가 가리키게 됨
    - 이후 `res1`은 `nullptr`로 초기화되었기 때문에 접근시 문제가 생길 수 있음
    - `std::move`는 개발자가 사용하는 것이기 때문에 이 실수는 개발자 책임

### Copy Semantics vs. Move Semantics

---

```cpp
#include <iostream>
#include <vector>
#include <utility>

int main()
{
    {
        vector<string> v;
        string str = "Hello";

        v.push_back(str);
        cout << str << endl;
        cout << v[0] << endl;

        v.push_back(std::move(str));
        cout << str << endl;
        cout << v[0] << " " << v[1] << endl;
    }
}
```
{: file="main.cpp"}

```text
- 출력 -

Hello
Hello
                // nullptr로 인해 비워진 부분
Hello Hello
```

- `vector`의 `push_back`은 L-Value Reference와 R-Value Reference에 따라 오버로딩되어 있음
- Copy Semantics 사용
  - `string str = "Hello";`
    - `str`은 L-Value로, `"Hello"`는 `str`이라는 이름의 다른 메모리 공간에 존재
    - `v[0]`이라는 새로운 공간을 만들어 `str`의 내용물을 깊은 복사해온 것
      - `v[0]`와 `str`은 같은 내용물이지만 별개의 공간
- Move Semantics 사용
  - `v.push_back(std::move(str));`
    - R-Value로, 깊은 복사 없이 `str`이 맡았던 `"Hello"` 객체는 `v[1]`이 맡게 되고 `str`은 `nullptr`로 초기화되었기
    - `str` 공간에 있던 `"Hello"` 객체가 복사된 것이 아닌 `v[1]`로 **이동**된 것

### 이동 생성자가 항상 빠른 것은 아님

---

- `move` 연산으로 더 성능이 좋아질 수 있는 케이스를 파악하는 것이 중요함
- 항상 `move` 연산이 복사보다 빠른 것은 아니며 `string`의 경우 `move` 연산을 지원하긴 하지만 문자열 길이가 짧은 경우엔 `move` 연산보다 복사가 성능이 더 나음
