---
title: "[C++] Chapter 9.12 대입 연산자 오버로딩, 깊은 복사, 얕은 복사"
date: 2025-10-28 16:14:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 88
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : 대입 연산자 오버로딩, 깊은 복사, 얕은 복사

- 얕은 복사 : 포인터 값인 **주소만 복사**하여 전달
- 깊은 복사 : 주소를 복사하여 전달하지 않고 **새로운 메모리를 할당받아 그 공간에 내용물만 복사**하는 것

### 얕은 복사

---

**기본 복사 생성자**  

```cpp
MyString(const& MyString other)  // 기본 복사 생성자
{
    m_data = other.m_data;
    m_length = other.m_length;
}
```

- 개발자가 정의하지 않아도 기본적인 복사 생성자를 가지고 있음
- 기본 복사 생성자는 생략되어 개발자 눈에 보이지 않지만 위와 같은 형태로 구현되어 있음

```cpp
#include <cassert>
#include <iostream>
using namespace std;

class MyString
{
public:
    char* m_data = nullptr; 
    int m_length = 0;

    MyString(const char* source = "") 
    {
        assert(source);

        m_length = std::strlen(source) + 1; 
        m_data = new char[m_length]; 

        for (int i = 0; i < m_length; i++) 
            m_data[i] = source[i];

        m_data[m_length - 1] = '\0'; 
    }

    ~MyString()  
    {
        delete[] m_data;
    }
};
```

- `char* m_data`
  - 이 멤버 포인터를 얕은 복사 방식을 복사하는 과정에서 문제가 발생

**얕은 복사 사용시 문제점**  

```cpp
int main()
{
    MyString hello("Hello");

    cout << (int*)hello.m_data << endl;
    // 014CFB00 출력
    cout << hello.m_data << endl;
    // Hello

    {
        MyString copy = hello;

        cout << (int*)copy.m_data << endl;
        // 014CFB00 출력
        cout << copy.m_data << endl;
        // Hello 출력
    }

    cout << hello.m_data << endl;
    // 硼硼硼硼硼硼硼硼핥퀪? 출력

    return 0;
}
```

- `{}` 지역 범위
  - `MyString copy = hello;`에서 `copy` 객체가 생성될 때 `hello`를 복사하므로 디폴트 복사 생성자가 호출됨
  - 이때 복사 생성자 내에 주소가 복사되면서 `copy` 객체의 `m_data` 포인터와 `hello` 객체의 `m_data` 포인터는 동일한 메모리를 가리키게 되며 이러한 과정을 **얕은 복사**라고 함
  - 이후 지역 범위가 끝나면서 `copy` 객체가 소멸되고 소멸자에 의해 `m_data`가 가리키는 동적 메모리가 해제됨
- `cout << hello.m_data << endl;`에서 얕은 복사에 의해 `hello` 객체의 `m_data`도 동적 할당 해제가 되었으므로 쓰레기 값이 출력됨

### 깊은 복사 구현

---

**깊은 복사와 얕은 복사 차이**  

- 다른 객체의 멤버 값들을 내 멤버로 복사해올 때 동적 메모리를 가리키는 포인터 멤버를 가지고 있는 클래스의 경우 얕은 복사를 이용하면 한 객체의 포인터가 할당 해제되면 다른 객체의 멤버도 그 공간을 가리켜 문제가 발생함
- 주소를 복사하지 않고 새로운 공간을 할당해 포인터 멤버가 가리키는 공간의 내용물만 복사해와 각 객체가 무관해지게 하는 복사를 **깊은 복사**라고 함

**복사 생성자와 대입 연산자 오버로딩의 차이**  

- 복사 생성자, `=` 대입 연산자 둘 다 복사를 한다는 점은 비슷함

1. 복사 생성자
   - 생성자이므로 객체가 생성되는 과정에 대입이 있는 경우 호출
  
    ```cpp
    MyString str1("Hello");
    MyString str2(str1);    // 복사 생성자 호출
    Mystring str3 = str1;   // 복사 생성자 호출
    ```
2. 대입 연산자 오버로딩
   - 단순히 이미 존재하는 객체끼리 대입시 호출

    ```cpp
    MyString str1("Hello");
    MyString str2;  

    str2 = str1;  // 대입 연산자 오버로딩 호출
    ```

    - 자기 자신을 대입하는 경우에 대한 처리가 필요하고 자기 자신의 동적 메모리를 해제하는 과정이 필요함

**깊은 복사 구현**  

```cpp
MyString(const MyString& source)    // 복사 생성자
{
    m_length = source.m_length; 

    if (source.m_data != nullptr) 
    {
        m_data = new char[m_length];  

        for (int i = 0; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = nullptr;
}
```

- 복사 대상인 `source` 객체의 `m_data`가 `nullptr`이라면 깊은 복사 실행
  - 포인터가 가리키는 곳을 참조해야 하므로 `nullptr` 체크 필수
- `nullptr`이 아니라면 `m_data`가 가리키는 내용물(배열의 원소들) 복사

```cpp
int main()
{
    MyString hello("Hello");

    cout << (int*)hello.m_data << endl;
    // 013DF918 출력
    cout << hello.m_data << endl;
    // Hello 출력

    {
        MyString copy = hello;

        cout << (int*)copy.m_data << endl;
        // 013DFAD8 출력
        cout << copy.m_data << endl;
        // Hello 출력
    }

    cout << hello.m_data << endl;
    // Hello 출력

    return 0;
}
```

- `copy` 객체가 `hello` 객체로부터 멤버 값들을 깊은 복사했기 때문에 `copy` 객체가 할당 해제가 되더라도 `hello` 객체에는 영향이 없음

**대입 연산자 오버로딩**  

- `=` 연산자 오버로딩은 **멤버 함수로만 구현 가능**

```cpp
MyString& operator = (const MyString & source)
{
    if (this == &source)
        return *this;

    delete[] m_data;

    m_length = source.m_length;

    if (source.m_data != nullptr)
    {
        m_data = new char[m_length];
        for (int i = 0; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = nullptr;
}
```

1. 자기 자신을 대입하는 경우 자기 자신을 리턴
2. 새로운 공간을 할당 받아야되기 때문에 기존 내용물을 비워줌
3. 깊은 복사 실행

```cpp
int main()
{
    MyString hello("Hello");

    cout << (int*)hello.m_data << endl;
    // 013DF918 출력
    cout << hello.m_data << endl;
    // Hello 출력

    {
      Mystring copy;
      copy = hello;

      cout << (int*)copy.m_data << endl;
      // 013DF918 출력
      cout << copy.m_data << endl;
      // Hello 출력
    }

    cout << hello.m_data << endl;
    // Hello 출력

    return 0;
}
```

- `copy` 객체가 `hello` 객체로부터 멤버 값들을 복사할 때 새로운 공간을 할당해 복사했기 때문에 `copy` 객체가 할당 해제가 되더라도 `hello` 객체에는 영향이 없음
