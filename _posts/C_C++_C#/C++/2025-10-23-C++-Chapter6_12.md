---
title: "[C++] Chapter 6.12 포인터와 const"
date: 2025-10-23 12:40:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 39
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## const의 위치에 따른 포인터

---

### const가 자료형 앞에 붙은 경우

```cpp
const int a = 5;
int b = 10;

const int* ptr_a = &a;
const int* ptr_b = &b;
int* ptr_f = &a; // Error !!!

ptr_a = nullptr;
```

- `const`가 데이터 타입 앞에 오는 경우 **간접 참조로 값을 수정할 수 없음**
  - `a`는 `const`가 붙은 상수이므로 값을 바꿀 수 없음
  - 간접 참조로 인하여 `a`의 값을 바꾸지 못하도록 `a`를 가리키는 포인터 `ptr_a` 또한 `const int*` 타입으로 선언되어야 함
  - `b`는 상수가 아닌 변수이지만 `b`를 가리키는 `ptr_b`가 `const int*` 타입으로 선언되었으므로 `ptr_b`로 `b`의 값을 바꿀 수 없음
      ```cpp
      cout << *ptr_b << endl;
      *ptr_b = 7; // Error !!!
      ```
- `int* ptr_f = &a;`에서 `a`는 상수인데 일반 포인터인 `ptr_f`가 간접 참조로 `a`의 값을 바꿀 수 있으므로 일반 포인터는 **상수를 가리킬 수 없음**
  - 포인터 또한 `const` 포인터여야 상수를 가리킬 수 있음
- 간접 참조로 값만 못바꾸는 것이지 포인터 자체의 값, 즉 주소값은 바꿀 수 있으므로 `ptr_a = nullptr`은 가능

```cpp
int a = 3;
int b = 7;

int* ptr1;
const int* ptr2 = &a;

ptr1 = ptr2; // Error !!!
```

- 일반 포인터에 `const` 포인터를 할당할 수 없음
  - 일반 `int*` 포인터인 `ptr1`이 `a`의 값을 바꿀 수 있으므로 안됨
  - `char*` 타입 변수에 `const char*` 문자열 상수를 대입할 수 없는 이유

### const가 변수 앞에 붙은 경우

```cpp
int a = 20;
int* const ptr = &a;

*ptr = 7;
ptr = &b; // Error !!!
```

- `ptr`의 값을 수정할 수 없음
  - 주소 값이 상수가 되어 수정 불가능하며 반드시 선언과 동시에 초기화가 되어야 함
  - 간접 참조로 가리키는 데이터의 수정은 가능함

**두 가지 경우 모두 가능**  

- `const int* const ptr`와 같은 표현도 가능함
  - 이때 간접 참조 수정도 불가능하고 `ptr` 값 수정도 불가능
