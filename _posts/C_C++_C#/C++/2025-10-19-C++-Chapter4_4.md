---
title: "[C++] Chapter 4.4 auto와 자료형 추론, 형변환"
date: 2025-10-19 14:33:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 19
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## auto

---

```cpp
auto a = 123;
auto a; // 오류 ! ! !

auto add (int x, int y)
{
  return x + y;
}

auto result = add(1, 2);
```

- `auto a = 123;`
  - 초기화되는 값 123으로 인해 `a`가 `int` 타입이라는 것을 추론
- `auto a;`
  - a가 어떤 데이터 타입인지 추론할 수 없음
- `auto add(int x, int y)`
  - 리턴 타입에도 `auto`를 사용할 수 있음
  - `return x + y;`에서 리턴 타입을 추론할 수 있기 때문
  - 파리미터는 컴파일 타임에서 자료형 추론이 불가능하기 때문에 `auto` 사용 불가능
- `auto result = add(1, 2);`
  - `add()`의 리턴 타입으로 `result`는 `int`가 됨

**리턴 타입이 auto인 함수에 템플릿 사용해보기**  

```cpp
auto add(int x, int y) → int;
auto add(int x, int y) → double;
```

- 템플릿을 사용하여 앞에는 `auto`로 쓰고 뒤에 리턴 타입을 명시해줌

## 형변환

---

**암시적 형변환**  

- 컴파일러가 알아서 형변환
  - `int a = 12.3;`
    - `double`인 12.3을 `int`로 강제 형변환

**명시적 형변환**  

- 개발자가 의도적으로 형변환

```cpp
// C 스타일 형변환
(int)4.0 

// C++ 스타일 형변환
int(4.0)
static_cast<int>(4.0)
```

**형 변환시 주의사항**  

- 큰 크기의 타입에서 작은 크기 타입으로 형변환할 때 데이터 손실이 발생함

  ```cpp
  float f = 0.123456789 // float에 double을 넣어 값이 손실됨
  ```

  - `float`은 4 byte, `double`은 8 byte이므로 `double`이 정밀도가 더 높음

  ```cpp
  cout << 5 - 10 //  -5 출력
  cout << 5u - 10 // 쓰레기 값이 출력
  ```

- `5u - 10`
  - `u`는 `unsigned int`, `5u`는 `unsigned int` 5를 뜻함
  - 형 변환에도 우선순위가 있기 때문에 쓰레기 값 출력
    - `unsigned int`가 `int`보다 우선순위가 높음
    - `int` < `unsigned int` < `long` < `unsinge long` < … < `float` < `double`
  - 형변환이 `unsigned int`로 되어, `unsigned int` 범위에 -5가 없기 때문
