---
title: "[C++] Chapter 12.9 객체 잘림과 reference_wrapper"
date: 2025-11-01 14:49:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 111
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 상속 : 객체 잘림과 reference_wrapper

### 객체 잘림

---

- 부모에 자식을 구겨 넣을 때 발생함
- 부모 타입 객체를 포함하기 때문에 자식 타입 객체가 부모 타입 객체보다 메모리 용량이 더 큼

```cpp
#include <iostream>
#include <vector>
#include <functional> // reference_wrapper

using namespace std;

class Base
{
public:
    int m_i = 0;

    virtual void Print()
    {
        cout << "I'm Base" << endl;
    }
};

class Derived : public Base
{
public:
    int m_j = 1;

    virtual void Print() override
    {
        cout << "I'm Derived" << endl;
    }
};
```

### 부모 타입의 포인터 & 참조로 자식 객체 가리키기

---

```cpp
Base& b1 = derived;
Base* b2 = new Derived();
```

- 부모 타입의 포인터 `Object*`나 참조 `Object&` 변수로 자식 객체를 가리킬 때 **객체 잘림 없이 다형성을 실현**

```cpp
int main()
{
    Derived d;
    Base & b1 = d;

    b.Print(); // I'm Derived 출력

    return 0;
}
```

- 단순히 `b1`라는 참조 변수가 `Derived` 타입 객체 `d`를 가리키고 있을 뿐이기 때문에 더 작은 메모리(부모)에 자식 객체를 구져 넣어 객체가 잘리는 일이 없음
  - 따라서 부모 타입의 포인터나 참조 변수로 자식 객체가 오버라이딩 한 내용을 호출할 수 있으며(가상 함수일 때) 이를 **다형성**이라고 함

### 부모 타입 객체에 자식 객체 집어 넣기

---

```cpp
Base b = d;
```

- 위와 같이 그저 부모 객체에 자식 객체를 우겨 넣으려고 하면 객체 잘림 현상이 발생해 다형성을 실행할 수 없음

```cpp
int main()
{
    Derived d;
    Base b = d;

    b.print();      // I'm Base 출력

    return 0;
}
```

- `b`가 `Base` 타입이라 `d`보다 메모리 용량이 작으므로 `d`를 우겨 넣으면 객체 잘림이 발생
  - `Base`로부터 상속받은 부분들만 `b`에 들어가게 됨

### reference_wrapper

---

- `#include <functional>`
- 일반 객체를 참조 형태로 리턴해주는 역할

```cpp
Base b;
Derived d;

std::vector<Base*> my_vec;
my_vec.push_back(&b);
my_vec.push_back(&d);

for (auto& ele : my_vec)
    ele->print();
```

- `vector`는 참조 형태의 원소는 받지 않으므로 다형성을 위해 위와 같이 포인터로 넣어줄 수 있음

```cpp
Base b;
Derived d;

std::vector<std::reference_wrapper<Base>> my_vec;
my_vec.push_back(b);
my_vec.push_back(d);

for (auto& ele : my_vec)
    ele.get().print();
```

- 참조 형태로 넣어주고 싶다면 위와 같이 `reference_wrapper`를 사용해 단순 객체인 `Base` 타입을 참조 형태로 리턴 받아 다형성을 실현할 수 있음
