---
title: "[C++] Chapter 6.14 참조와 const"
date: 2025-10-31 13:25:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 41
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 참조와 const

---

```cpp
int x = 5;
const int& ref = x; // ref를 통해 x값을 읽기만 가능

const int x = 5;
int& ref = x; // Error !!!

const int x = 5;
const int& ref = x;

const int x = 5;
const int& ref = x;
const int& ref2 = ref; // 참조 변수가 다른 참조 변수를 참조하는것 가능

int x = 5;
int& ref = x;
const int& ref2 = ref; // ref2로는 x의 값을 바꾸는 것이 불가능하지만 ref로는 x의 값을 바꿀 수 있다.
```

## const 포인터와 const 참조의 차이

---

```cpp
int a = 3;
int b = 7;

int* ptr1;
const int* ptr2 = &a;

ptr1 = ptr2;  // Error !!!
// const int*인 ptr2를 그냥 int*인 ptr1에 대입할 수 없음
        
int c = 300;
int d = 700;

const int& ref2 = d;
int& ref1 = c;

ref1 = ref2;
```

- 참조 타입 변수에 `const` 참조 타입 변수를 대입하는 것은 단순히 값을 복사하는 것이기 때문에 가능
- 포인터는 주소 값을 복사해서 넘겨주는 과정에서 일반 포인터가 간접 참조로 값을 변경할 우려가 있어 일반 포인터에 `const` 포인터를 할당하는 것은 불가능

## const 참조 변수는 R-Value도 참조 가능

---

- `const` 참조 변수는 L-Value, R-Value 모두 참조 가능

```cpp
int & ref = 5; // 불가능 : 일반 참조 변수는 L-value 변수만 참조 가능
const int & ref = 5; // 가능 : const 참조 변수는 L-value, R-value 모두 참조 가능
```

```cpp
void func (const int& x) { ... }

int main()
{
  int a = 2;
  
  func(a); 
  func(3 + 1);
}
```

- `func(a)`
  - 복사 과정 없이 `const int&`인 지역 변수 `x`가 `a`의 메모리를 참조
    - 복사 과정이 생략되어 성능이 향상됨
  - `const` 참조 변수라서 `a`의 값을 수정할 수는 없음
- `func(3 + 1)`
  - `const int&`로 전달받으므로 R-Value를 매개변수로 전달 가능
