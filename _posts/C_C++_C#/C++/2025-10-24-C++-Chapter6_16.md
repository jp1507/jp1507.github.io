---
title: "[C++] Chapter 6.16 for-each 반복문"
date: 2025-10-24 15:09:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 43
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 범위 기반 반복문 for-each

---

```cpp
for(auto i : 배열이름)
```

- C++ 11 이상부터 지원
- `auto`
  - 반복자 `i`의 데이터 타입
  - 배열의 타입에 따라 자료형 결정
- `auto i`에 배열의 원소들이 순서대로 대입됨
- `i`는 `for`문 내 지역 변수

## 일반 데이터 타입 반복자

---

```cpp
int main()
{
  int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };

  for (auto number : fibonacci)
    number *= 10;

  cout << endl;

  return 0;
}
```

- `auto`에 의해 `number`의 타입은 `int`로 추론
- `fibonacci` 배열의 원소들이 인덱스 순서대로 `number`에 **복사**됨
  - 배열의 크기가 클 경우 시간이 오래 걸리고 공간이 낭비될 수 있음
- `number`는 단순히 각각의 원소의 값을 복사한 것이기 때문에 `number`의 값을 수정해도 배열의 원래 값은 변함 없음

## 참조 반복자

---

```cpp
int main()
{
  int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };

  for (auto& number : fibonacci)
    number *= 10;

  cout << endl;

  return 0;
}
```

- `fibonacci` 배열의 원소들이 인덱스 순서대로 `number`에 **참조**됨
  - 복사되는 과정이 없이 `number`가 차례대로 `fibonacci`의 원소들과 메모리를 공유
  - `number`의 값을 수정하면 원래 배열 원소들의 값도 수정됨

## const 참조 반복자

---

```cpp
int main()
{
  int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };

  for (const auto& number : fibonacci)
    cout << number << endl;

  cout << endl;

  return 0;
}
```

- `const` 참조 변수는 참조하는 대상의 값을 변경할 수 없음
  - 원소의 값을 변경하지 못하도록 막을때 사용
  - 성능 문제로 반복자 타입을 참조로 하려고 하는데 원소 값을 못바꾸게 하고 싶을 때

## 동적 배열에서 for-each문

---

- 동적 배열은 `for-each`문을 사용 못하지만 `vector`는 사용할 수 있음

```cpp
#include<iostream>
#include <limits>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
  vector<int> fibonacci = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };

  for (const auto& n : fibonacci)
    cout << number << endl;

  cout << endl;

  return 0;
}
```
