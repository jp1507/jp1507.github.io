---
title: "[C++] Chapter 7.2 인수 전달(값, 참조, 주소에 의한 전달)"
date: 2025-10-25 13:12:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 49
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 7. 함수

### 1. 값에 의한 인수 전달

---

```cpp
void func(int x) 
{
  x = 20;
}
int main()
{
  int a = 0;
  func(a); 
  cout << a << endl; // 0 출력
}
```

- `func(a)` 함수 호출시 내부적으로 `int x = a`가 실행됨
  - 함수의 지역 변수이자 매개변수인 `int x`에 `a`의 값이 **복사**됨
    - 단순히 복사된 것이기 때문에 함수가 실행된 이후 `a`의 값에는 변함이 없음
  - 인수의 값이 복사되어 매개변수에 넘겨지는 것을 값에 의한 인수 전달(call by value)라고 함

### 2. 참조에 의한 전달

---

- 함수를 통해 인수(argument)의 값을 바꾸고 싶을 때 사용
- C와 C++은 반환을 하나만 할 수 있기 때문에 인수로 넘길 여러 변수들을 함수로 수정하고 싶으면 포인터 또는 참조를 통해 인수로 전달함

```cpp
void func(int& x) 
{
  x = 20;
}
int main()
{
  int a = 0;
  func(a); 
  cout << a << endl; // 20 출력
}
```

- `func(a)` 함수 호출시 내부적으로 `int& x = a`가 실행됨
  - 참조 변수 `x`는 `main()`의 `a` 변수의 별명이 되어 메모리를 공유
    - 함수 실행 후 `a`의 값은 20으로 바뀜
  - `x`의 주소와 `a`의 주소는 같음
  - `x`는 지역 변수이므로 함수안에서만 `a`의 별명으로 존재

```cpp
void func1(int& x) 
{
  cout << x << endl;
}
void func2(const int& x) 
{
  cout << x << endl;
  x = 20; // Error !!! const 참조 변수이므로 수정 안됨
}

int main()
{
  int a = 0;

  func1(6); // Error !!! 6은 R-value
  func1(a);

  func2(6);
  func1(a);
}
```

- 일반 참조 변수는 L-Value만 참조 가능
  - 메모리 공간이 잡혀있는 L-Value의 별명만 될 수 있음
- `const` 참조 변수는 L-Value, R-Value 모두 참조 가능
  - `const`이기 때문에 참조하는 대상의 값을 변경할 수 없음

```cpp
void func(int*& ptr)
{
    cout << ptr << endl;
}
int main()
{
    int x = 5;
    int * ptr_x = &x;

    func(ptr_x);
}
```

- 포인터에 대한 참조는 매개변수 타입이 `*&`이고 이는 곧 `(int*)&`와 같음(`ptr`은 `int*` 포인터 타입의 참조 변수)

```cpp
void func(int (&arr)[4])
{
    for (auto& elements : arr)
      cout << elements << endl;
}
int main()
{
    int array[4] = {1, 2, 3, 4};
    func(array);
}
```

- 배열에 대한 참조는 미리 `[]`를 이용해 크기를 지정해야함
- 함수 호출 시 인수로 배열 이름만 전달하면 됨

```cpp
void func(vector<int>& arr)
{
    for (auto & elements : arr)
      cout << elements << endl;
}
```

- `vector` 참조 타입시 단순히 `&`만 사용하면 됨

### 3. 주소(포인터)에 의한 전달

---

```cpp
void func(int* ptr)
{
  *ptr = 100;
}
int main()
{
  int value = 5;
  int* ptr_value = &value;

  func(ptr_value);
  func(&value);
  func(5); // Error !!!
}
```

- `func()`의 `ptr`은 `int*` 포인터 타입인 지역 변수이자 매개변수
- 참조와 다르게 `ptr`과 `ptr_value`는 주소가 다른 별개의 변수
  - `ptr_value`는 `int` 변수인 `value`의 주소를 담고 있고 `ptr`은 `ptr_value`로부터 해당 `value`의 주소 값을 **복사**한 것일 뿐(call by value)
- **간접 참조**를 통해 값을 수정할 수 있음
  - 함수 내 `*ptr = 100`을 통해 `value`의 값 또한 100으로 바뀜
