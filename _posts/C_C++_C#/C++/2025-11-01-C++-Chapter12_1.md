---
title: "[C++] Chapter 12.1 다형성의 기본 개념"
date: 2025-11-01 13:05:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 103
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 함수 : 다형성의 기본 개념

### 다형성 활용 전

---

- 부모 타입의 포인터 하나로 여러 자식들의 멤버를 호출할 수 있음을 이용

```cpp
class Animal
{
protected:
    string m_name;
public:
    Animal(std::string name) : m_name(name) {}
    string GetName() { return m_name; }

    void Speak() const
    {
        cout << m_name << " ??? " << endl;
    }
};

class Cat : public Animal
{
public:
    Cat(string name) : Animal(name) {}

    void Speak() const
    {
        cout << m_name << "Meow " << endl;
    }
};

class Dog : public Animal
{
public:
    Dog(string name) : Animal(name) {}

    void Speak() const
    {
        cout << m_name << "Woof " << endl;
    }
};

int main()
{
    Animal animal("my animal");
    Cat cat("my cat");
    Dog dog("my dog");

    animal.speak();  // "my animal ???" 출력
    cat.speak();     // "my cat Meow" 출력
    dog.speak();     // "my dog Woof" 출력

    Animal* ptr_animal1 = &cat;
    Animal* ptr_animal2 = &dog;

    ptr_animal1->speak();  // "my cat ???" 출력
    ptr_animal2->speak();  // "my dog ???" 출력

    return 0;
}
```

- C++은 참조하는 대상의 타입이 아닌 호출하는 변수의 타입에 따라 멤버를 호출하기 때문에 `ptr_animal1->speak()`와 `ptr_animal2->speak()` 모두 `Animal` 객체의 `Speak()` 함수가 호출됨

### 다형성을 사용하는 이유

---

```cpp
cat.speak()
dog.speak()
rabbit.speak()
pig.speak()
cow.speak()
lion.speak()
...
```

- `Animal` 객체의 자식 종류가 여러가지라면 다형성을 사용하지 않을때 자식 타입의 변수로 멤버를 호출해줘야하는 번거로움이 발생

```cpp
Animal* animals[] = { &cat, &dog, &pig, &lion }; 

for(int i = 0; i < 4; i++)
    animals[i]->speak();
```

- 위와 같이 부모 타입 포인터 컨테이너에 자식들을 넣고 `for` 문을 통해 `animals[i]->speak();`로 각각 모든 오버라이딩 함수를 호출하게 하려면 `Animal` 클래스에서 `Speak()`를 **가상 함수**로 지정하면 됨

### 가상 함수 virtual

---

- 부모 타입 포인터로 자식 객체를 가리킬 시 자식이 오버라이딩한 것을 호출하게 하고 싶은 멤버 함수를 `virtual` 가상 함수로 지정

```cpp
class Animal
{
protected:
    string m_name;
public:
    Animal(std::string name) : m_name(name) {}
public:
    string GetName() { return m_name; }

    virtual void Speak() const
    {
        cout << m_name << " ??? " << endl;
    }
};
```

- 멤버 함수 앞에 `virtual` 키워드를 붙여주면 가상 함수로 선언됨
  - 부모 타입의 포인터로 호출하더라도 자식 클래스가 오버라이딩 한 함수를 호출하게 끔 함
  - 따라서 자식 클래스에서 해당 함수를 오버라이딩하길 권장되고, 자식 클래스에서 오버라이딩 되어있지 않으면 부모 함수가 호출됨
