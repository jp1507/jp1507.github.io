---
title: "[C++] Chapter 8.9 클래스와 const"
date: 2025-10-27 16:09:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 70
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 8. 객체 지향의 기초 : 클래스와 const

### const가 붙은 객체

---

```cpp
const Friend f;

f.SetValue(2);    // Error !!!
f.GetValue(2);    // Error !!!
```

- 객체 선언시 `const`가 붙었을 때, 그 객체의 멤버의 값을 바꿀 수 없음
- setter 함수 사용이 불가능하고, 접근만하는 getter 함수도 사용 불가능
  - 멤버를 바꾸지 않는 것이 확실한 `const` 멤버 함수만 사용 가능
  - 컴파일러는 멤버 값을 바꿨는지에 대한 판단보단 멤버 함수가 `const`인 것인지로 판단

**`const` 키워드가 수식된 멤버 함수만 사용 가능**  

- `const`가 붙은 객체의 멤버 함수는 `const` 멤버 함수만 사용할 수 있음
- 일반 전역 함수는 `const`를 붙일 수 없고 **멤버 함수만 가능**

```cpp
int GetValue() const
{
    return m_value;
}

const Friend f;

f.SetValue(2);    // Error !!!
f.GetValue(2);
```

- 멤버 함수 뒤에 `const`를 붙여 멤버 값을 변경하지 않을 것이라고 명시해줌
- `const`가 아닌 객체에서도 `const` 멤버 함수를 호출할 수 있음
- 매개변수가 `const` 객체인 함수들은 인수로 전달받아 사용할 때 마찬가지로 `const` 멤버 함수만 사용할 수 있음

### 복사 생성자

---

```cpp
class Something
{
public:
    int m_value = 0;

    Something()
    {
      cout << "Constructor" << endl;
    }
      
    void setValue(int value) { m_value = value; }
    int getValue() const { return m_value; }
};
```
{: file="Something.h" }

```cpp
void print(Something st)
{
    cout << &st << endl;
    cout << st.m_value << endl;
}

int main()
{
    Something something;
    cout << &something << endl;
    print(something);

    return 0;
}
```
{: file="main.cpp" }

- `print()`을 호출하면서 매개변수인 `st`에 `main()` 함수에서 생성된 `something` 객체가 복사됨
  - 매개변수이자 지역 변수인 `st`도 `Something` 객체로서 생성됨
  - 이때 2번 생성되므로 생성자도 2번 호출되어야 하지만 실제 출력은 1번만 출력됨
    - 매개변수에 복사되는 `Something st = something`이 실행될 때 클래스에 숨겨져 있는 **복사 생성자**가 호출되었기 때문

```cpp
Something (const Something& st_in)
{
    m_value = st_in.m_value; // 멤버 복사
}
```

- Call by Value 형태로 전달
- 매개변수인 `st` 객체가 생성되면서 복사하는 같은 타입의 대상이 있으므로 복사 생성자가 호출됨
- `st_in`은 복사 없이 `Something` 그 자체를 참조(Call by Reference)
- `st_in.m_value`의 값을 `st`의 멤버 `m_value`에 대입(복사)함

```cpp
class Something
{
public:
    int m_value = 0;

    Something(const Something& st_in)   // 복사 생성자 정의
    {
      m_value = st_in.m_value;
      cout << "Copy constructor" << endl;
    }
    Something()
    {
      cout << "Constructor" << endl;
    }
      
    void setValue(int value) { m_value = value; }
    int getValue() const { return m_value; }
};

void print(Something st)
{
    cout << &st << endl;
    cout << st.m_value << endl;
}

int main()
{
    Something something;
    cout << &something << endl;
    print(something);

    return 0;
}
```

- 복사 생성자를 개발자가 직접 구현해서 사용할 수 있음

```cpp
void print(const Something& st)
{
    cout << &st << endl;
    cout << st.m_value << endl;
}
```

- `const Something& st`와 같이 매개변수를 설정하면 복사되는 것이 아니라 그 자체를 참조하게 되므로 복사 생성자가 호출되지 않음

**복사 생성자가 호출될 때**  

1. 먼저 생성된 객체를 나중에 생성된 객체의 생성자 인자로 전달할 때
2. 함수의 인자로 객체를 Call by Value 형태로 전달할 때
3. 객체를 Call by Value 형태로 리턴할 때

### const 함수의 오버로딩

---

```cpp
#include <iostream>
#include <string>

class Something
{
public:
    string m_value = "default";

    const string & getValue() const
    {
        cout << "const version" << endl;
        return m_value;
    }
    string & getValue()
    {
        cout << "non-const version" << endl;
        return m_value;
    }
}

int main()
{
    Something s1;
    s1.getValue();   // string& getValue() 호출

    const Something s2;
    s2.getValue();  // const string& getValue() const 호출
}
```

- `const`의 유무도 오버로딩의 고려 대상
- 보통 멤버 함수를 `const`로 만들 땐 리턴 타입도 `const`로 함
  - `const`가 앞에 붙은 함수
    - 단순히 리턴을 변경할 수 없는 상수로 설정
  - `const`가 뒤에 붙은 함수
    - `const` 객체만 사용할 수 있는 함수로, 멤버 값을 변경하지 않음
