---
title: "[C++] Chapter 7.9 std::vector를 스택처럼 사용하기"
date: 2025-10-26 13:59:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 56
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 7. 함수 : std::vector를 스택처럼 사용하기

### std::vector

---

```cpp
#include <vector>

std::vector<int> vec{1, 2, 3, 4, 5};
int* v_ptr = new int[5] {1, 2, 3, 4, 5};
```

- `vector`도 동적 할당을 받아 힙 메모리를 사용하므로 `new`로 동적 할당 받는 것과 비슷함

### vector의 size와 capacity

---

- capacity
  - 실제로 메모리를 차지하는 원소 개수
  - 벡터가 실제로 차지하는 메모리 공간
  - 벡터의 여유 메모리 공간과 같음
  - 원소 추가시 `new`, `delete` 없이 capacity 내에서 공간을 가져옴
- size
  - capacity 중에서 실 사용 개수

```cpp
#include <iostream>
#include <vector> // 이게 필요하다

using namespace std;

int main()
{
  std::vector<int> v{1, 2, 3};

  for (auto &e : v)
    cout << e << " ";
  cout << endl;
  /// 1 2 3 출력

  cout << v.size() << endl;  // 3 출력

  v.resize(2); // 벡터의 사이즈를 2로

  for (auto &e : v)
    cout << e << " ";
  cout << endl;
  // 1 2 출력

  cout << v.size() << " " << v.capacity() << endl;
  // 2 3 출력

  int* ptr = v.data();
  cout << ptr[2] << endl;  // 3 출력  

  return 0;
}
```

- v.resize(2) : `v`의 size를 2로 수정
- v.size() : `v`의 size 반환
- v.capacity() : `v`의 capacity 반환
- v.data() : `v`가 사용하는 힙 메모리의 주소를 리턴
- ptr[2]
  - size가 2로 변경되어 3번째 원소를 접근할 수 없게 되었지만 Heap 메모리의 주소를 받아 강제로 3번째 원소에 접근

- `vector`는 빠른 속도를 위해 `resize`시에도 `new`, `delete`를 자제하는 방향으로 설계 되었음
  - `resize()`를 통해 `v[2]` 원소를 접근하지 못하게 막아둘 뿐임
  - capacity 값은 3으로 출력되므로 실제 메모리를 차지하는 원소 개수는 3임

### vector의 resize와 reserve

---

- `resize(n)` : size를 n으로 변경
- `reserve(n)` : capacity를 n으로 변경. n개의 원소를 담을 수 있을 만큼 메모리 용량 확보

```cpp
std::vector<int> v{1, 2, 3};
v.resize(10);

for (auto& e : v)
   cout << e << " ";
cout << endl;
// 1 2 3 0 0 0 0 0 0 0 출력

cout << v.size() << " " << v.capacity() << endl;
// 10 10 출력
```

```cpp
std::vector<int> v{1, 2, 3};
v.reserve(1024);
// ✨reserve✨

for ( auto &e : v)
   cout << e << " ";
cout << endl;
// 1 2 3 출력

cout << v.size() << " " << v.capacity() << endl;
// 3 1024 출력
```

- `v`의 메모리를 1024개의 원소가 포함될 수 있을 만큼 여유를 둔 것일 뿐 실제 원소는 3개
- 이렇게 capacity를 증가시키면 `v`에 원소를 추가할 때 동적 할당 없이 바로 여유 공간을 가져옴

### vector를 스택처럼 사용

---

- `vector`에는 `push_back()`, `pop_back()` 함수가 내장되어 있고 이는 `stack`의 `push`와 `pop` 연산과 비슷함
- 스택을 `vector`로 쓰는 이유
  1. push, pop 함수가 있음
  2. 속도가 더 빠름
     - push를 할 때, `vector`는 동적 할당 없이 미리 할당 받은 capacity를 가져옴
     - pop할 때, capacity는 그대로 유지되고 size만 줄어들어 pop한 원소를 배제함
