---
title: "[C++] Chapter 3.3 비트 연산, 비트 플래그, 비트 마스크"
date: 2025-10-18 14:05:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 15
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Bitwise Operators

---

- `<<`, `>>`, `~`, `&`, `|`, `^`
- `#include <bitset>`
- `std::bitset<4>(x)`
  - 십진수를 이진수 비트로 표현
  - x 값을 4자리 이진수 비트로 출력
- Bitwise 연산은 메모리를 의미있게, 빠르게 계산하기 위해 사용
  - 단순한 곱하기, 나누기 연산보다 Shift 연산이 더 빠름
- 비트 연산은 `unsigned`를 사용

```cpp
unsigned int a = 0b1100;
unsigned int b = 0b0110;

cout << a ; // 12 출력
cout << b ; // 6 츨력
```
```cpp
#include <bitset>

unsigned int a = 3;
cout << std::bitset<4>(a) << endl; 
// 0011 출력(3의 4자리 이진수)
```

## Shift 연산

---

### Left Shift(`<<`)

- 0011 << 2 → 2칸 왼쪽 → 1100
- A << N은 곧 A $\times 2^n$ 하는 것과 마찬가지
- 따라서 Left Shift 연산으로 곱하면 더 빠름

```cpp
 #include <bitset>

unsigned int b = a << 1;
cout << std::bitset<4>(b) << endl;
```

### Right Shift(`>>`)

- 1011 >> 2 → 2칸 오른쪽 → 0010
- A >> N은 곧 A $÷ 2^n$ 하는 것과 마찬가지
- 따라서 Right Shift 연산으로 나누면 더 빠름

## 보수 연산자

---

- `~` 연산자는 비트에 보수를 취함
  - ~1100 = 0011

## 비트 논리 연산자

---

- 2개의 비트 피연산자의 논리 관계
  - 결과 값은 `bool` 타입
  - 각 자리끼리 연산
- `&` : AND
- `|` : OR
- `^` : XOR

```cpp
unsigned int a = 0b1100;
unsigned int b = 0b0110;

cout << std::bitset<4>(a & b) << endl; // 0100
cout << std::bitset<4>(a | b) << endl; // 1110
cout << std::bitset<4>(a ^ b) << endl; // 1010
```

## 비트 플래그와 비트 마스크

---

### 비트 플래그

각 비트 자리에 유무 플래그를 표시하면 간편하게 여러 `bool` 타입을 관리할 수 있음

- `unsigned int` 변수 하나가 32 bits를 가지고 있으므로 각 비트 자리를 대치시켜 32개의 `bool` 타입 변수를 사용하는 것처럼 쓸 수 있음

```cpp
#include <bitset>

/* 이렇게 각 아이템 유무 상태들만 정의 */
const unsigned char opt0 = 1 << 0; // 00000001  아이템 0을 가진 상태 정의
const unsigned char opt1 = 1 << 1; // 00000010  아이템 1을 가진 상태 정의
const unsigned char opt2 = 1 << 2; // 00000100  아이템 2을 가진 상태 정의
const unsigned char opt3 = 1 << 3; // 00001000  아이템 3을 가진 상태 정의
const unsigned char opt3 = 1 << 4; // 00010000  아이템 4을 가진 상태 정의
const unsigned char opt3 = 1 << 5; // 00100000  아이템 5을 가진 상태 정의
const unsigned char opt3 = 1 << 6; // 01000000  아이템 6을 가진 상태 정의
const unsigned char opt3 = 1 << 7; // 10000000  아이템 7을 가진 상태 정의

cout << bitset<8>(opt0) << endl; // 00000001 출력
cout << bitset<8>(opt1) << endl; // 00000010 출력
cout << bitset<8>(opt2) << endl; // 00000100 출력 
cout << bitset<8>(opt3) << endl; // 00001000 출력 

unsigned char items_flag = 0; // 현재는 00000000 로 초기화. 아이템 없는 상태.
```

- `1 << n` 연산으로 각 아이템 유무를 표현
- `opt` 변수들의 조합으로 `items_flag`를 활용해 보유 상태를 표현

**아이템을 얻었을 때(`|=`)**  

```cpp
unsigned char items_flag = 0; // 00000000 로 초기화, 아이템 없는 상태
cout << "No item " << bitset<8>(items_flag) << endl; // 00000000 출력

items_flag |= opt0; // 아이템 0을 얻음
cout << "item 0 obtained " << bitset<8>(items_flag) << endl; // 00000001 출력

items_flag |= (opt2 | opt3); // 아이템 2와 3 을 얻음 (opt2 | opt3) → 000001100
cout << "item 2, 3 obtained " << bitset<8>(items_flag) << endl; // 00001101 출력
```

**아이템을 잃었을 때(`&=`)**  

```cpp
// items_flag는 현재 00001101 상태 

items_flag **&= ~** opt3; // 아이템 3 을 잃음
cout << "item 3 losted " << bitset<8>(items_flag) << endl; // 00000101 출력
```

**아이템 소유 상태를 확인(`&`)**  

```cpp
if (items_flag & opt1) //itmes_flag의 아이템 1 자리 확인
  cout << "Has item1" << endl;
else
  cout << "Not have item1" << endl;
```

**아이템 유무 상태를 뒤바꾸기(`^=`)**  

```cpp
// items_flag는 현재 00000101 상태
if ((items_flag & opt2) && !(items_flag & opt1))
{
  items_flag ^= opt1; // 00000111
  items_flag ^= opt2; // 00000011
}

cout << bitset<8>(items_flag) << endl; // 00000011 출력
```

### 비트 마스크

- 색상을 표현할 때 1 byte 3개로 표현(총 24 bits)
  - 16진수 하나로 4 bit 표현 가능
    - 0 ~ 9 → 0000 ~ 1001
    - A → 1010
    - B → 1011
    - C → 1100
    - D → 1101
    - E → 1110
    - F → 1111
    - FF → 11111111
  - 16진수 2자리 수로 각각 적색, 청색, 녹색을 표현하며 조합해서 다양한 색을 표현함(0xRRGGBB)

**비트 플래그를 이용해 청색 추출**  

```cpp
const unsigned int blue_mask = 0x0000FF;
unsigned int pixel_color = 0xDAA520;

cout << std::bitset<32>(blue_mask) << endl;
cout << std::bitset<32>(pixel_color) << endl;

unsigned char blue = pixel_color & blue_mask;

cout << "blue " << bitset<8>(blue) << endl;
```

**비트 플래그를 이용해 녹색 추출**  

```cpp
const unsigned int green_mask = 0x00FF00;
unsigned int pixel_color = 0xDAA520;

unsigned char green = pixel_color & green_mask;
green = (pixel_color & green_mask) >> 8

cout << "green " << bitset<8>(green) << endl;
```
