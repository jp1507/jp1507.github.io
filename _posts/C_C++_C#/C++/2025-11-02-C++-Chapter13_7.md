---
title: "[C++] Chapter 13.7 포인터에 대한 템플릿 특수화"
date: 2025-11-02 14:13:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 120
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 13. 템플릿 : 포인터에 대한 템플릿 특수화

- 특수화 : 템플릿에서 특정 타입에 대해 다른 실행 처리를 하고 싶을 때 그 타입에 대해서만 특수화

### 포인터에 대한 템플릿 특수화 X

---

```cpp
#include <iostream>
using namespace std;

template<typename T>
class A
{
private:
    T m_value;
public:
    A(const T & input) : m_value(input) {}
    void Print()
    {
        cout << m_value << endl;
    }
};

int main()
{
    A<int> a_int(123);
    a_int.Print();
    
    int temp = 456;
    
    A<int*> a_int_ptr(&temp);
    a_int_ptr.Print();
    
    double temp_d = 3.141592;
    A<double*> a_double_ptr(&temp_d);
    a_double_ptr.Print();
}
```
```text
-출력-

123
0117FD68
0117FD4C
```

- `A<int*>`, `A<double*>`와 같이 포인터 데이터 타입에 대한 구체화
- *"0117FD68"* 이런식으로 주소값 그대로를 출력하는데 포인터로 구체화 됐을 때는 특수하게 간접 참조 값을 출력하게 하고 싶을 때

### 모든 포인터 타입에 대한 특수화

---

```cpp
template<typename T>
class A
{
private:
    T m_value;
public:
    A(const T & input) : m_value(input) {}
    void Print()
    {
        cout << m_value << endl;
    }
};

template<typename T>
class A<T*>
{
private:
    T* m_value;
public:
    A(T* input) : m_value(input) {}
    void Print()
    {
        cout << *m_value << endl;
    }
};

int main()
{
    A<int> a_int(123);
    a_int.Print();
    
    int temp = 456;
    
    A<int*> a_int_ptr(&temp);
    a_int_ptr.Print();
    
    double temp_d = 3.141592;
    A<double*> a_double_ptr(&temp_d);
    a_double_ptr.Print();
}
```
```text
-출력-

123
456
3.145192
```

- `T*`를 이용해 `int*`, `float*`, `char*` 등 모든 포인터 타입에 대한 특수화를 할 수 있음
- 따라서 `T`를 생략하면 안되기 때문에 `template<>`이 아닌 `template<typename T>`까지 명시해주어야 함
- 포인터 타입에 대한 특수화를 했기 때문에 포인터 값이 아닌 그 주소가 참조하는 간접 참조 값이 출력됨을 알 수 있음
