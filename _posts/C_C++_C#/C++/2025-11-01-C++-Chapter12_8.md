---
title: "[C++] Chapter 12.8 가상 상속으로 다이아몬드 상속 문제 해결"
date: 2025-11-01 14:32:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 110
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 함수 : 가상 상속으로 다이아몬드 상속 문제 해결

### 다이아몬드 상속 문제

---

![이미지1](https://imgur.com/qyEl42L.png)

- 왼쪽과 같이 `C`에 `A`가 하나만 존재할 것 같지만 실제로는 오른쪽처럼 `C`에 `A` 타입 메모리가 2개가 생김
- 다중 상속시, 다이아몬드 구조로 상속되는 것이 아닌 손자 객체에 조상 객체가 2개 생성됨

```cpp
#include <iostream>
using namespace std;

class PoweredDevice
{
public:
    int m_i;

    PoweredDevice(int power)
    {
        cout << "PoweredDevice: " << power << "\n";
    }
};

class Scanner : public PoweredDevice
{
public:
    Scanner(int scanner, int power) : PoweredDevice(power)
    {
        cout << "Scanner: " << scanner << "\n";
    }
};

class Printer : public PoweredDevice
{
public:
    Printer(int printer, int power) : PoweredDevice(power)
    {
        cout << "Printer: " << printer << "\n";
    }
};

class Copier : public Scanner, public Printer
{
public:
    Copier(int scanner, int printer, int power) : Scanner(scanner, power), Printer(printer, power) {}
};

int main()
{
    Copier cop(1, 2, 3);

    cout << &cop.Scanner::PoweredDevice::m_i << endl;
    cout << &cop.Printer::PoweredDevice::m_i << endl;

    return 0;
}
```
```text
- 출력 -

PoweredDevice : 3
Scanner : 1
PoweredDevice : 3
Printer : 2
000000A95D0FF9EC
000000A95D0FF9E8
```

- 조상 클래스인 `PoweredDevice`의 생성자가 2번 호출됨
  - 즉, 손자 클래스인 `Copier` 타입 객체 `cop`에 `PoweredDevice` 타입 사본이 2개가 존재할
- `m_i`는 `PoweredDevice`로부터 상속 받은 멤버 변수로, `Scanner`와 `Printer`로부터 받은 `m_i`의 주소가 다른 것으로 보아 다른 두 개의 `PoweredDevice` 타입 객체가 상속되었음을 알 수 있음

### 가상 상속

---

- `virtual`로 가상 상속 받으면 상속시 부모 타입의 메모리가 중복되지 않으면서 상속됨
  - 단, 다중 상속하는 손자 클래스의 경우 조상 클래스의 생성자를 꼭 직접 호출해주어야 함

```cpp
#include <iostream>
using namespace std;

class PoweredDevice
{
public:
    int m_i;

    PoweredDevice(int power)
    {
        cout << "PoweredDevice: " << power << "\n";
    }
};

class Scanner : virtual public PoweredDevice
{
public:
    Scanner(int scanner, int power) : PoweredDevice(power)
    {
        cout << "Scanner: " << scanner << "\n";
    }
};

class Printer : virtual public PoweredDevice
{
public:
    Printer(int printer, int power) : PoweredDevice(power)
    {
        cout << "Printer: " << printer << "\n";
    }
};

class Copier : public Scanner, public Printer
{
public:
    Copier(int scanner, int printer, int power) : Scanner(scanner, power), Printer(printer, power), PoweredDevice(power) {}
};

int main()
{
    Copier cop(1, 2, 3);

    cout << &cop.Scanner::PoweredDevice::m_i << endl;
    cout << &cop.Printer::PoweredDevice::m_i << endl;

    return 0;
}
```
```text
- 출력 -

PoweredDevice : 3
Scanner : 1
Printer : 2
000000A95D0FF998
000000A95D0FF998
```

- `Scanner`와 `Printer`는 `PoweredDevice`를 가상 상속받고 있어 `Copier`에 `PoweredDevice`이 중복되지 않고 단 하나만 존재함
- `Copier`의 생성자에서 따로 직접 `PoweredDevice` 타입 생성자를 호출해야 함
  - `PoweredDevice`를 가상 상속 받은 후 그 자식인 `Scanner`와 `Printer`는 더 위로 올라가지 않기 때문임
    - 직접 호출하지 않을 때 컴파일러가 디폴트 생성자를 호출하는데 현재 매개변수가 있는 생성자가 있으므로 직접 호출해야 에러가 발생하지 않음
