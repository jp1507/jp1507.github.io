---
title: "[C++] Chapter 8.2 캡슐화, 접근 지정자, 접근 함수"
date: 2025-10-27 13:36:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 63
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 8. 객체 지향의 기초 : 캡슐화, 접근 지정자, 접근 함수

### 캡슐화

---

- 외부로부터 중요한 데이터와 기능을 보호하고 은닉하는 것

### 접근 지정자

---

- 접근 지정자를 명시해주지 않으면 기본 값으로 `private`이 지정됨

1. `public` : 외부의 모든 곳에서 접근 가능
2. `private` : 클래스 내의 멤버 함수에서만 접근 가능
3. `protected` : 클래스 내 멤버 함수와 상속 받은 자식 클래스의 멤버 함수에서 접근 가능

```cpp
#include <iostream>
using namespace std;

class Date
{
    int m_year;

public:
    int m_month;
    int m_day;
};

int main()
{
    Date today; 

    today.m_day = 25;

    today.m_year = 1994;    // Error !!!
    cout << today.m_month << endl;    // Error !!!

    return 0;
}
```

- `public`
  - `today.m_day`는 접근 가능
- `private`
  - `today.m_year = 1994;`는 에러
    - 외부에서 직접 값을 수정할 수 없음
  - `cout << today.m_month << endl;`는 에러
    - 외부에서 직접 값을 사용할 수 없음

### 접근 함수 Setter, Getter

---

- `private` 멤버 변수들은 `public`한 접근 함수들을 만들어 이를 통해 간접 접근해야 함

**Setter : private 멤버 변수 값 수정**  

```cpp
#include <iostream>
using namespace std;

class Date
{
    int m_month;
    int m_day;
    int m_year;
public:
    void SetDate(const int& month_input, const int& day_input, const int& year_input)
    {
        m_month = month_input;
        m_day = day_input;
        m_year = year_input;
    }

    void SetYear(const int& year_input)
    {
        m_year = year_input;
    }
};

int main()
{
    Date today; 

    today.SetDate(8, 4, 2025);
    today.SetYear(2020); 

    return 0;
}
```

**Getter : private 멤버 변수 값 반환**  

```cpp
#include <iostream>
using namespace std;

class Date
{
    int m_month;
    int m_day;
    int m_year;
public:
    const int & GetYear() { return m_year; }
};

int main()
{
    Date today; 
    cout << today.GetYear() << endl;

    return 0;
}
```

- Getter 접근 함수는 리턴 타입을 `const int&`으로 하는 것을 권장
  - 멤버 변수 값을 변경하는 것 없이 반환만 하는거라 `const` 지정 무방
  - 복사 과정을 줄여 메모리 성능을 높이기 위해 참조로 받음

**다른 객체의 멤버들을 복사해오는 접근 함수**  

```cpp
#include <iostream>

using namespace std;

class Date
{
    int m_month;
    int m_day;
    int m_year;
public:
    void SetDate(const int& month_input, const int& day_input, const int& year_input)
    {
      m_month = month_input;
      m_day = day_input;
      m_year = year_input;
    }

    const int & GetMonth() { return m_month; }
    const int & GetDay() { return m_day; }
    const int & GetYear() { return m_year; }

    void CopyFrom(const Date& origin)
    {
      m_month = original.m_month;  
      m_day = original.m_day;
      m_year = original.m_year;
    }
};

int main()
{
    Date today;
    Date tomorrow;

    today.SetDate(8, 4, 2025);
    tomorrow.CopyFrom(today);

    return 0;
}
```

- `void CopyFrom(const Data& origin)`
  - `Data` 클래스 타입의 다른 객체를 매개변수로 받아 그 객체의 멤버 변수의 값들을 내 멤버 변수들에 복사
  - `tommorow.SetDate(today.getMonth(), today.getDay(). today.getYear())`을 `tomorrow.copyFrom(today)`로 간단하게 쓸 수 있음

```cpp
void CopyFrom(const Date& original)
{
    m_month = original.m_month;  
    m_day = original.m_day;
    m_year = original.m_year;
}
```

- 서로 다른 별개의 객체더라도 클래스 타입이 동일하면 각 멤버는 서로의 `private` 멤버 변수 접근이 가능
  - 접근 지정자의 접근 제어 기준은 인스턴스 기준이 아닌 클래스 기준이기 때문

### 캡슐화를 고려하면 좋은 점

---

- 클래스 내 멤버 변수 이름을 바꿔야 할 경우 해당 변수를 접근하여 사용한 모든 부분을 바꿔야 하는데, 캡슐화되어 있다면 클래스 내부에서만 수정하면 안전하고 편리함
- 멤버 변수들은 `private`으로 막아두는 것을 권장
