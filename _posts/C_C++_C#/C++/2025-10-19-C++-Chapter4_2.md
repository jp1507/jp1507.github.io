---
title: "[C++] Chapter 4.2 정적 변수, 전역 변수, 내·외부 연결"
date: 2025-10-19 13:41:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 17
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 정적 변수 `static`

---

```cpp
void doSomething()
{
  static int a = 1;
  ++a;
  cout << a << endl;
}

int main()
{
  doSomething(); // 2 출력,첫 호출! 이 때 a의 초기화가 1로 처음이자 마지막으로 이루어진다. 
  doSomething(); // 3 출력
  doSomething(); // 4 출력
  doSomething(); // 5 출력
}
```

**정적(`static`) 변수 특징**  

1. 초기화는 처음 호출될 때 딱 한번 함
   - 반드시 초기화 해주어야 함
2. `static` 변수의 데이터 값은 메모리에 유지됨, 즉 값이 유지됨
   - OS로부터 받은 메모리가 정적이라는 뜻
3. 해당 블록 안에서만 사용이 가능
   - 전역 변수는 코드 내 모든 곳, 다른 파일에서도 사용될 수 있음
   - 정적 변수는 메모리 값이 유지된다는 면에서 전역 변수와 비슷하지만 지역 변수로서 해당 블록에서만 사용 가능

## 전역 변수

---

- `main()` 함수 밖에서 선언
- 어떤 중괄호 `{}` 안에 귀속되어 있지 않는 변수
- 지속 기간이 없고 프로그램이 종료되면 사라짐
- 따라서 최소한 필요한 만큼 사용해야 함

**전역 변수 종류**  

- `static` 전역 변수 : 이 cpp 파일 내 사용 가능
- `extern` 전역 변수 : 다른 파일에서도 사용 가능하고 메모리가 공유됨
  - `extern`은 생략 가능하며 전역 변수의 기본은 `extern`임

**Linking 링킹**  

- include한 다른 코드 파일과 연결하는 작업
- 컴파일러가 링킹시 include한 다른 코드 파일 전체를 **복사**해오는 방식

**extern**  

- 초기화 꼭 해주기
  - 선언만 하면 쓰레기 값이 들어가 있어 사용하면 문제가 발생할 수 있음
  - 선언만 하더라도 다른 곳에서 초기화할 수 있음
- `extern`으로 선언된 변수와 함수는 이미 메모리에 할당되어있는 다른 파일의 전역 변수와 메모리를 공유하겠다고 선언할 때는 `extern` 키워드를 생략할 수 없음

```cpp
int a = 123; 
```
{: file="aaa.h" }

- 다른 파일에서 복사해서 사용한다는 의미로 `extern` 키워드 생략

```cpp
#include "aaa.h"
using namespace std;

extern int a;

int main()
{
  cout << a << endl; // 123 출력
}
```
{: file="main.cpp"}

- aaa.h의 전역 변수 `a`와 메모리를 공유할 것이기 때문에 `extern`으로 선언
- 여기 `a`는 aaa.h의 `a`를 뜻함

```cpp
namespace Constants
{
  const double pi(3.141592);
  const double gravity(9,8);
}
```
{: file="MyConstants.h" }

```cpp
#include "MyConstants.h"

int main()
{
  cout << Constants::pi << endl;
}
```
{: file="main.cpp" }

- `#include "MyConstants.h"`
  - main.cpp의 `Constants::pi`와 MyConstants.h의 `pi`는 별개
  - MyConstants.h에서 복사한 것이기 때문에 이름만 같고 다른 변수이고 메모리 공유 X
- 이런 경우, MyConstants.h가 다른 곳에서 다수 include 된다면 `pi` 변수의 사본이 다수 생기게 되므로 메모리가 낭비됨
- 값이 바뀔 위험이 없는 `const` 전역 변수는 `extern`을 붙여 계속 복사되어 메모리를 늘릴 필요 없이 메모리를 공유해서 쓰일 수 있도록 하는 것이 좋음

```cpp
namespace Constants
{
  extern const double pi(3.141592);
  extern const double gravity(9,8);
}
```
{: file="MyConstants.h" }

- 위와 같이 `extern` 키워드를 붙이면 linking 시 컴파일러 내부적으로 MyConstants.h 코드를 복사함
- 이제 MyConstants.h의 사본을 쓰는 것이 아닌 MyConstants.h의 `pi` 자체 메모리를 공유하게 됨

```cpp
namespace Constants
{
  extern const double pi;
  extern const double gravity;
}
```
{: file="MyConstants.h" }

```cpp
#include "MyConstants.h"

Constants::pi = 3.141592;
Constants::gravity = 9.8;
```
{: file="MyConstants.cpp" }

- 헤더 파일에서 `extern` 변수를 선언
- 소스 파일에서 초기화를 해줌

**정리**  

- `extern` 생략된 extern 전역 변수
  - 다른 파일에서 사본으로 사용, 별개의 메모리
- `extern` 명시된 extern 전역 변수
  - 다른 파일에서도 같은 메모리 공유

```cpp
/* 초기화 X */
int g_x;  // external. 다른 파일에서 사본으로 쓰인다. 
static int g_x; // internal. 다른 파일에서 쓰일 수 없다. 이 코드 내에서만 쓰일 수 있음
const int g_x; // external. 에러! const는 꼭 초기화를 해주어야함
extern int g_z; // 이 파일을 include 하는 다른 파일에서 이 변수와 메모리를 공유하게 될 것.
extern const int g_z; // 에러 아님! 이 변수와 메모리를  공유하는 다른 파일에서 초기화 꼭 해주면 됨.

/* 초기화 O */
int g_y(1); // external. 
static int g_y(1); // internal. 
const int g_y(1); // external. 
extern int g_w(1); // 이제 다른 파일에서 정의가 불가능하다. 
extern const int g_w(1); 
```
