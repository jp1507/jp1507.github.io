---
title: "[C++] Chapter 7.3 다양한 반환 값"
date: 2025-10-25 13:40:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 50
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 7. 함수 : 다양한 반환 값

### 1. 값을 리턴

---

```cpp
int GetValue(int x)
{
    int value = x * 2;
    return value;
}

int main()
{
    int value = GetValue(3);
    return 0;
}
```

1. `GetValue(3)`
   - 함수가 호출되고 인수 3이 전달되면 매개변수에 3이 복사됨
     - 내부적으로 `int x = 3`이 실행
     - `GetValue()` 함수의 지역 변수인 `value`가 리턴
2. `int value = GetValue(3);`
   - `GetValue()`의 리턴 값인 `value`가 `main()`의 `value`에 **복사**됨
   - `GetValue()`가 끝나면 지역 변수인 `value`도 메모리에서 제거됨

- 값을 리턴하는 함수가 많아지면 다수의 복사가 발생하므로 느려질 수 있음
  - 구조체, 클래스, 배열 등에 사용하면 비효율적인 방법
  - 변수 하나를 리턴하는 경우 값을 리턴 하는 것이 효율적이고 안전함

### 2. 주소를 리턴

---

```cpp
int* AllocateMemory(int size)
{
  return new int[size];
}

int main()
{
  int* arr = AllocateMemory(1024);
  delete [] arr;
  return 0;
}
```

1. `AllocateMemory(1024)`
   - 함수가 호출되고 인수로 1024가 전달되어 `int size = 1024`가 실행됨
2. `int* array = AllocateMemory(1024);`
   - `AllocateMemory()`의 리턴 값인 `new int[size]`가 `main()`의 `int* arr`에 대입됨
     - `new`는 동적 할당 메모리의 주소 값을 리턴하므로 주소 값이 `main()`의 `int* arr`에 대입
     - `new`는 힙 메모리에서 동적 할당 받기 때문에 함수 범위가 끝나도 사라지지 않고 `delete`를 통해 반납하기 전까지 계속 남아있음
   - 지역 변수인 `size`만 사라짐

```cpp
int* GetValue(int x)
{
  int value = x * 2;
  return &value;
}

int main()
{
  int* value_1 = GetValue(3);
  int value_2 = *GetValue(3);

  return 0;
}
```

- R-Value 주소 값을 반환하는 경우 `value`는 지역 변수이므로 리턴 후 메모리가 해제되고 사라지기 때문에 이 변수의 주소를 넘기는 것은 위험할 수 있음
  - `int* value_1 = GetValue(3);` : 메모리에서 제거된 값의 주소를 받음
  - `int value_2 = *GetValue(3);` : 메모리에서 제거된 값의 주소를 간접 참조함
- 따라서 포인터 리턴은 지양하는 것이 좋음
- 함수 내에서 선언된 지역 변수를 받환하는 경우 **주소 리턴**을 하면 위험함

### 3. 참조를 리턴

---

```cpp
int& GetValue(int x)
{
  int value = x * 2;
  return value;
}

int main()
{
  int value = GetValue(3);
  return 0;
}
```

1. `GetValue(3)`
   - 함수 호출 시 인수 3이 전달되고 매개변수에 3이 복사됨
   - 지역 변수인 `value`의 값 6이 리턴됨
2. `int value = GetValue(3);`
   - `main()`의 `value`는 `GetValue()`에서 리턴한 `value`가 참조하는 메모리를 **복사**받음
     - 함수는 리턴 타입이 `int&`이 되므로 `value`에 대한 참조를 리턴
   - `int&` 참조로 리턴하면 L-Value로서 반환하게 되는데 `GetValue()` 함수가 종료되면 지역 변수이자 참조 변수인 `value`도 메모리에서 잠깐 있다가 해제되므로 `main()`의 `value`는 없어진 메모리 공간을 복사 받은 것과 같음
   - 따라서 실행 결과 *warning: reference to local variable ‘value’ returned [-Wreturn-local-add]*와 같은 경고 메세지 출력

```cpp
int& GetValue(int x)
{
    int value = x * 2;
    return value;
}

int main()
{
    int& value = GetValue(3);

    cout << value << endl; // 6 출력
    cout << value << endl; // 쓰레기 값 출력

    return 0;
}
```

- `int& value = GetValue(3);`
  - 함수의 지역 변수인 `value`의 메모리 공간을 참조 변수 `int&`인 `value`가 참조
  - 함수가 종료되면 지역 변수인 `value`의 메모리 공간이 파괴됨
  - `main()`의 `value`는 계속해서 파괴된 메모리 공간을 참조
    - 한번 더 출력하면 쓰레기 값이 출력됨
  - 함수 내에서 선언된 지역 변수를 반환하는 경우 참조 타입으로 리턴하는 것을 지양해야함

```cpp
int& Get(std::array<int, 100>& my_arr, int idx)
{
    return my_arr[idx];
}
int main()
{
    std::array<int, 100> my_arr;
    my_arr[30] = 10;

    Get(my_arr, 30) = 1024; // my_array[30] = 1024
}
```

- 인수를 기존에 `main()`에서 메모리를 할당 받은 배열을 참조로 넘김
  - `Get()` 함수 내의 `my_arr`는 함수가 종료되어도 사라지지 않고 계속 존재하므로 기존 공간을 참조 매개변수로 넘기고 이를 리턴 받을 경우는 위험하지 않음
- `Get(my_arr, 30) = 1024;`
  - 참조로 리턴했기 때문에, 즉 L-Value로 리턴했기 때문에 변수에 값을 저장하는 것처럼 보임

**정리**  

1. `int` 값 리턴 : **임시 변수**에 리턴된 객체를 **복사**한 후 그 임시 변수를 **R-Value** 속성으로 리턴
   - 즉, 해당 객체가 아닌 주소가 다른 임시 변수의 메모리가 리턴
2. `int&` 참조 리턴 : 임수 변수 복사 없이 실제 객체 그 자체를 **L-Value** 속성으로 리턴
   - 리턴하는 것이 함수 내 지역 변수라면 소멸 시점을 주의해야 함

### 4. 구조체를 리턴

---

```cpp
using namespace std;

struct S
{
  int a, b, c, d;
};

S GetStruct()
{
  S my_s{1, 2, 3, 4};
};

int main()
{
  S my_s = GetStruct();
  cout << my_s.b << endl;

  return 0;
}
```

- 구조체를 리턴받아 값을 받을 경우 한 번에 여러 개의 값을 받을 수 있음
- 함수를 하나 만들 때마다 구조체 또한 또 만들어야 하는게 단점

### 5. 튜플을 리턴

---

```cpp
#include <tuple>
using namespace std;

std::tuple<int, double> GetTuple() 
{
  int a = 10;
  double d = 3.14;
  
  return std::make_tuple(a, d);
}
int main()
{
  std::tuple<int, double> my_tp = GetTuple();
  cout << std::get<0>(my_tp) << endl; // a. int다
  cout << std::get<1>(my_tp) << endl; // b. double이다.

  return 0;
}
```

- `#include <tuple>`
- 튜플은 대괄호(`[]`)를 사용함
- 튜플을 통해 각각 데이터 타입이 다른 두 개 이상의 리턴값을 받을 수 있음
- C++ 17 이상 `std::tuple<int, double> tp = GetTuple();`을 간단하게 `auto [i, d] = GetTuple();`로 사용할 수 있음
