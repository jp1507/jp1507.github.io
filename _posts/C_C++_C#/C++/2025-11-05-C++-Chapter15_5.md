---
title: "[C++] Chapter 15.5 std::unique_ptr"
date: 2025-11-05 13:45:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 131
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : std::unique_ptr

### 스마트 포인터

---

- `#include <memory>`
- 모든 스마트 포인터가 공통적으로 가지는 특징은 포인터가 참조하고 있는 동적 메모리를 자동으로 할당 해제해주는 것
- 따라서 개발자가 직접 할당 해제를 명시해줄 필요가 없으며 메모리 누수를 방지해줌
  - `if-else`문이나 예외를 만나 일찍 `return` 되는 등으로 `delete`를 만나기 못한 경우를 방지
- `->`, `*` 연산도 오버로딩 되어있기 때문에 일반 포인터처럼 사용 가능함
- 스마트 포인터의 종류
  1. `unique_ptr`
  2. `shared_ptr`
  3. `weak_ptr`
- 선언할 때 일반 포인터처럼 `*`를 붙이지 않음
    ```cpp
    Resource * res = new Resource(1000000);  // 일반 포인터
    std::unique_ptr<Resource> res(new Resource(1000000)); // 스마트 포인터
    ```

### unique_ptr

---

- 특정 객체에 유일한 소유권(unique)을 부여하는 포인터 객체
  - 포인터가 가리키고 있는 데이터의 소유권이 한 곳에만 속할 경우 사용
  - 이 객체를 잘 보관하고 막아주겠다는 성격

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Resource
{
public:
  int* m_data = nullptr;
  unsigned m_length = 0;
public:
  Resource()
  {
      cout << "Resource constructed" << endl;
  }

  Resource(unsigned length) 
  {
      cout << "Resource length constructed" << endl;
      this->m_data = new int[length];
      this->m_length = length;
  }

  Resource(const Resource& res)
  {
      cout << "Resource copy constructed" << endl;

      Resource(res.m_length);

      for (unsigned i = 0; i < m_length; ++i)
          m_data[i] = res.m_data[i];
  }

  ~Resource()
  {
      cout << "Resource destroyed" << endl;
  }

  Resource& operator =(Resource& res)
  {
      cout << "Resource copy assignment" << endl;

      if (&res == this) 
          return *this; 

      if (this->m_data != nullptr) 
          delete[] m_data; 

      m_length = res.m_length; 

      m_data = new int[m_length]; 
      for (unsigned i = 0; i < m_length; ++i) 
          m_data[i] = res.m_data[i];

      return *this;
  }

  void Print()
  {
    for(unsigned i = 0; i < m_length; i++)
        std::cout << m_data[i] << " ";
    std::cout << std::endl;
  }

  void SetAll(const int& v)
  {
    for(unsigned i = 0; i < m_length; i++)
        m_data[i] = v;
  }
};

int main()
{
  {
    std::unique_ptr<int> upi(new int);

    auto *ptr = new Resource(5);
    std::unique_ptr<Resource> res1(ptr);

    res1->SetAll(5);
    res1->Print();
  }
}
```
```text
- 출력 -

Resource length constructed
5 5 5 5 5
Resource destroyed
```

### std::unique_ptr 함수들

---

**`std::make_unique` 함수**  

- `unique_ptr` 인스턴스를 안전하게 생성
- 전달 받은 인수를 사용하여 지정된 타입의 객체를 생성하고 생성된 객체를 가리키는 `unique_ptr`을 리턴 받을 수 있음

```cpp
int main()
{
    {
        std::unique_ptr<int> upi(new int);

        auto res1 = std::make_unique<Resource>(5);
        //std::unique_ptr<Resource> res1 = new Resource(5); 

        res1->SetAll(5);
        res1->Printf();
    }
}
```

- `auto res1 = std::make_unique<Resource>(5);`
   1. 생성자를 호출하고 객체를 생성한 후
   2. 이 객체를 가리키는 `unique_ptr`를 리턴해 `res1`에 복사(얕은 복사)
- `std::unique_ptr<Resource> res1 = new Resource(5);`
  - 리턴 없이 단순히 `unique_ptr`를 선언하는 것

**`get()` 함수**  

- `unique_ptr` 자체에서 가지고 있는 함수로 일반 포인터를 리턴함

```cpp
void DoSomething2(Resource* res)
{
    res->SetAll(100);
    res->Print();
}

int main()
{
    auto res1 = std::make_unique<Resource>(5);
    DoSomething2(res1.get());
}
```

### std::unique_ptr의 특징

---

```cpp
// res1, res2는 unique_ptr 타입의 스마트 포인터
auto res1 = std::make_unique<Resource>(5);
std::unique_ptr<Resource> res2;

res2 = res1; // Error !!!
res2 = std::move(res1);
```

- Copy Semantics가 안되므로 복사할 수 없고 컴파일 에러가 발생
  - `unique_ptr`은 한 객체의 소유권은 오직 한 곳에서만 가질 수 있기 때문
- Move Semantics는 가능하여 이동만 할 수 있음
  - `res2 = std::move(res1);`
    - `res1`이 R-Value로 바뀌고 `res1`의 소유권이 박탈되어 아무 객체도 가리키지 않는 `nullptr`이 되며 `res2`가 `res1`이 소유하던 객체의 소유권을 물려받게 됨
  - 한 객체의 소유권이 오직 한 곳에서만 가질 수 있는 성질이 보장됨
- 이처럼 서로의 단순 복사를 막아 어떤 객체에 대한 소유권을 한 곳에서만 소유할 수 있도록 보장해줌

```cpp
auto DoSomething()
{
    return std::unique_ptr<Resource>(new Resource(5));
}

int main()
{
    {
        auto res1 = std::make_unique<Resource>(5);

        res1->SetAll(5);
        res1->Print();

        std::unique_ptr<Resource> res2;

        // std::boolalpha : 0, 1 대신 true, false 출력. null이면 false출력.
        std::cout << std::boolalpha;  
        std::cout << static_cast<bool>(res1) << std::endl; // true 출력
        std::cout << static_cast<bool>(res2) << std::endl; // false 출력

        res2 = std::move(res1);

        std::cout << std::boolalpha;
        std::cout << static_cast<bool>(res1) << std::endl; // false 출력
        std::cout << static_cast<bool>(res2) << std::endl; // true 출력

        if (res1 != nullptr)
            res1->Print();
        if (res2 != nullptr)
            res2->Print();
    }
}
```
```text
- 출력 -

Resource length constructed
5 5 5 5 5
true
false
false
true
5 5 5 5 5
```

- 함수의 리턴 값이 R-Value이니까 `unique_ptr`를 리턴하는 `DoSomething()`은 `unique_ptr`를 R-Value로서 리턴하는 것과 같음
- `res2 = std::move(res1);`
  - `res1`이 가리키던 객체의 소유권이 `res2`에게로 이전되었기 때문에 `res1`은 소유권이 박탈되어 `nullptr`이 됨

```cpp
Resource * res = new Resource;
std::unique_ptr<Resource> res1(res);
std::unique_ptr<Resource> res2(res);   // Error !!!

delete res;  // 문제가 생길 여지가 있음
```

- 일반 포인터 `res`가 가리키고 있는 객체를 `unique_ptr`인 `res1`과 `res2`가 동시에 소유하려고 하면 오류가 발생
- 스마트 포인터인 `unique_ptr`은 스코프를 벗어나면 자동으로 할당 해제가 되기 때문에 개발자가 `delete`를 명시해주는 것이 컴파일 에러는 아니지만 이미 할당 해제되었는데 다시 할당 해제하려는 시도가 될 수 있어 문제가 생길 수 있음

### std::unique_ptr을 함수 파라미터로 전달하는 경우

---

- `unique_ptr`을 함수 파라미터로 넘겨받을 때 레퍼런스로 받을 것을 권장함

```cpp
void DoSomething2(std::unique_ptr<Resource>& res)
{                                                  
    res->SetAll(10); 
}

int main
{
    {
        auto res1 = std::make_unique<Resource>(5);
        res1->SetAll(1);
        res1->Print();

        DoSomething2(res1);
        res1->Print();
    }
}
```

- `unique_ptr`의 레퍼런스가 아닌 것으로 전달받으면 컴파일 에러가 발생
- `unique_ptr`은 가리키는 객체에 대해 소유권이 유일해야해서 **복사**를 금지하기 때문
- 레퍼런스가 아닌 일반 `unique_ptr`로 전달받고 싶다면 `std::move`로 소유권을 넘겨서 사용할 수 있음
  - 이때 함수에서 다시 그 객체를 리턴하면 기존의 `unique_ptr`의 소유권을 유지할 수 있음

```cpp
auto DoSomething2(std::unique_ptr<Resource> res)
{                                                   
    res->SetAll(100);  
}

int main
{
    {
      auto res1 = std::make_unique<Resource>(5);
      res1->SetAll(1);
      res1->Print();

      DoSomething2(res1);  // Error !!!
      res1 = DoSomething2(std::move(res1));

      res1->print();
    }
}
```

- `get()` 함수를 이용해 일반 포인터로 잠시 변환하여 전달할 수 있음

```cpp
void DoSomething2(Resource* res)
{
    res->SetAll(100);
    res->Print();
}

int main()
{
    auto res1 = std::make_unique<Resource>(5);
    DoSomething2(res1.get());
}
```
