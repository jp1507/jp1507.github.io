---
title: "[C++] Chapter 12.2 가상 함수와 다형성"
date: 2025-11-01 13:20:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 104
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 11. 가상 함수 : 가상 함수와 다형성

### virtual 유무 차이

---

**가상 함수 비사용**  

```cpp
#include <iostream>
using namespace std;

class A
{
public:
    void Print() { cout << "A" << endl; }
};
class B : public A
{
public:
    void Print() { cout << "B" << endl; }
};
class C : public B
{
public:
    void Print() { cout << "C" << endl; }
};
class D : public C
{
public:
    void Print() { cout << "D" << endl; }
};

int main()
{
    A a;
    B b;
    C c;
    D d;

    A &ref1 = b;
    ref1.print();  // "A" 출력

    C &ref2 = d;
    ref2.print();  // "C" 출력

    return 0;
}
```

- `B` 타입 객체인 `b`를 참조하더라도 `ref1`은 `A` 타입이기 때문에 `A`의 `Print()`가 호출됨
- `D` 타입 객체인 `d`를 참조하더라도 `ref2`은 `C` 타입이기 때문에 `C`의 `Print()`가 호출됨

**가상 함수 사용**  

```cpp
#include <iostream>
using namespace std;

class A
{
public:
    virtual void Print() { cout << "A" << endl; }
};
class B : public A
{
public:
    void Print() { cout << "B" << endl; }
};
class C : public B
{
public:
    void Print() { cout << "C" << endl; }
};
class D : public C
{
public:
    void Print() { cout << "D" << endl; }
};

int main()
{
    A a;
    B b;
    C c;
    D d;

    A &ref1 = b;
    ref1.print();  // "A" 출력

    C &ref2 = d;
    ref2.print();  // "C" 출력

    return 0;
}
```

- `virtual` 가상 함수로 지정된 함수를 호출할 때, 참조하는 객체의 타입에 따라 호출됨
  - 부모 포인터로 호출하더라도 자식이 오버라이딩한 함수 호출
  - `ref1.Print()`는 가상 함수이므로 `B` 타입 객체인 `b`를 참조하기 때문에 오버라이딩된 `Print()`가 호출됨
- 조상 클래스의 `virtual` 가상 함수는 모든 자식, 손자 클래스에 유지됨
  - 조상 클래스의 가상 함수를 자식 클래스에서 `virtual`을 쓰지 않더라도 그대로 가상 함수임
  - 대대손손 유지되므로 `C` 타입인 `ref2`의 `Print()`를 호출하더라도 `D`의 `Print()`가 호출됨

### 주의사항

---

1. 오버라이딩할 때 리턴 타입까지도 같아야 함
2. `virtual` 가상 함수는 스택처럼 쌓아서 처리되는게 아닌 가상 함수 테이블을 사용해 조상으로 찾아 올라가는 방식이라 조금 느림
