---
title: "[C++] Chapter 12.5 동적 바인딩과 정적 바인딩"
date: 2025-11-01 13:59:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 107
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 함수 : 동적 바인딩과 정적 바인딩

### 정적 바인딩 Static Binding

---

- 컴파일 시점에서도 어떤 함수가 호출될지 명백히 알 수 있는 경우

```cpp
int Add(int x, int y)
{
    return x + y;
}
int Subtract(int x, int y)
{
    return x - y;
}

int main()
{
    int x, y;
    cin >> x >> y;

    int op;

    cout << "0: add, 1: subtract" << endl;
    cin >> op;

    int result;
    switch(op)
    {
        case 0 : result = Add(x, y); break;
        case 1 : result = Subtract(x, y); break;
    }
}
```

- 실행 전, 빌드 타입에 이미 변수명, 함수 이름들이 모두 정의되어 있음
- 실행 중에 함수를 찾을 필요 없이 `op = 0`으로 `Add()` 함수가 실행되는 것을 미리 알 수 있음

### 동적 바인딩 Dynamic Binding

---

- 어떤 함수가 호출될지 런타임 중에 결정됨

```cpp
int main()
{
    int x, y;
    cin >> x >> y;

    int op;

    cout << "0: add, 1: subtract" << endl;
    cin >> op;

    int(*func_ptr)(int, int) = nullptr;
    switch(op)
    {
        case 0 : func_ptr = add; break;
        case 1 : func_ptr = subtract; break;
    }
}
```

- 런타임 중에 `func_ptr`에 함수의 주소가 저장되며 런타임 때 직접 함수 포인터를 보고 해당 함수를 찾아가 호출해야 함

### 비교

---

- `static binding`
  - 이미 실행할 함수가 미리 결정되어있어 훨씬 빠름
  - 실행 전 미리 다 정의가 되어있어 유연성이 떨어짐
- `dynamic binding`
  - 런타임 중 함수를 직접 찾아가 실행해야해서 느림
  - 유연하고 자유도가 높아 게임 프로그래밍에 필수적
