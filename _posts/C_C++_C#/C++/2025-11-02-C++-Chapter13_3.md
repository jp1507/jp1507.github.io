---
title: "[C++] Chapter 13.3 자료형이 아닌 템플릿 매개변수"
date: 2025-11-02 13:29:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 116
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 13. 템플릿 : 자료형이 아닌 템플릿 매개변수

### 컴파일 타임에 정해지는 값으로만 구체화

---

```cpp
#include <iostream>

template <typename T, unsigned int T_SIZE>
class MyArray
{
private:
    T* m_data;   
public:
    MyArray()
    {
        m_data = new T[T_SIZE];
    }
    ~MyArray()
    {
        reset();
    }

    void Reset()
    {
        delete [] m_data;
        m_data = nullptr;
    }
    T & operator [](int index)
    {
        assert (index >= 0 && index < T_SIZE); 
        return m_data[index];
    }
    int GetLength()
    {
        return T_SIZE;
    }
    void Print()
    {
        for (int i = 0; i < T_SIZE; i++)
            std::cout << m_data[i] << " ";
        std::cout << std::endl;
    }
};
```
{: file="MyArray.h"}

- `T_SIZE`는 `unsigned int` 타입으로 템플릿 매개변수
  - 컴파일 타임에 결정되어야 하기 때문에 클래스 템플릿을 구체화할 때  `T_SIZE`로 `unsigned int` 타입 상수 리터럴을 전달

```cpp
#include "MyArray.h"

int main()
{
    MyArray<double, 100> my_array;

    for(int i = 0; i < my_array.GetLength(); i++)
        my_array[i] = i + 65;

    my_array.Print();

    return 0;
}
```

- `T_SIZE`에 100을 넣어 `for` 문에서 100번 반복되고 멤버인 `m_data`의 크기는 100이 됨

```cpp
int a = 100;
MyArray<double, a> my_array;    // Error !!!

const int b = 100;
MyArray<double, b> my_array;
```

- 일반 변수는 컴파일 때 메모리가 정해지지 않아 불가능하지만 `const` 상수는 컴파일 상수이므로 가능
