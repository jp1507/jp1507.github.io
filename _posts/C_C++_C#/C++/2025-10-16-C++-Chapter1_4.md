---
title: "[C++] Chapter 1.4 컴파일, 헤더 파일 만들기, 헤더 가드"
date: 2025-10-16 15:11:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 4
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 컴파일 과정

---

- 컴파일 역할
  - 문법 체크 + `static` 영역들의 메모리 할당 수행
    - 프로그램이 실행되기 전에 미리 메모리에 할당되어 있어야 할 부분(컴파일 타임)
- 헤더 파일은 컴파일 되지 않음
  - 헤더 파일은 `include`한 cpp 파일 내에 전체 복사될 뿐
- 그 다음에 컴파일 완료된 cpp 파일들을 링킹함

## 헤더 파일 만들기

---

- 한 코드 파일에 모든 내용을 다 넣는건 좋지 않음
- `#include "add.h"`를 선언하면
  - add.h 헤더 파일에 정의해 놓은 함수와 변수들을 마음대로 사용 가능
  - add.h 헤더 파일은 프로젝트와 동일한 위치에 있어야 함
    - 다른 위치에 있으면 `#include "myfolder/add.h"`와 같이 상대 파일 경로를 명시
  - add.cpp 파일 또한 add.h와 같은 위치에 있어야 함

## 헤더 가드

---

- 헤더 파일에는 함수의 원형만 씀
- 헤더와 이름이 같은 cpp 파일에 함수의 정의와 바디를 씀
- `include`한 cpp 파일에서 이 함수들을 사용함

ex)

1. add.h 헤더 파일에 `int add(int x, int y);`라는 원형을 선언
2. add.cpp 소스 파일에 `int add(int x, int y);`라는 바디를 정의
3. 이때, add.cpp 파일을 **remove** 시키면 컴파일은 성공하지만 함수의 바디가 무시되기 때문에 링킹 에러가 발생함
  → 문법 상으로 괜찮지만 실행할 때 문제가 발생함

cf)  

- remove : 파일 삭제가 아니라 파일을 무시하라는 의미(빌드할 때 사용하지 않음)
- delete : 파일 영구 삭제

**헤더 가드를 사용하는 이유**  

- 헤더 가드는 헤더 재정의를 방지하기 위해 사용한다.
  
헤더 파일 안에서 함수 바디까지 정의하는 경우, 문제가 발생할 수 있다.

ex)  

똑같은 헤더 파일이 이중으로 불러와져서 똑같은 바디가 두 번 복사되는 일  

```cpp
int add(int x, int y)
{
  return x + y;
}
```
{: file="add.h" }

```cpp
#include "add.h"

void work()
{
  add(1, 2);
}
```
{: file="work.h" }

```cpp
#include "add.h"
#include "work.h"

int main()
{
  cout << add(3, 4) << endl;
  work();
}
```
{: file="main.cpp" }

- main.cpp 컴파일 시
  1. `cout << add(3, 4) << endl;`에서 add.h 파일로부터 함수 정의와 바디를 main.cpp에 복사
  2. `work();`에서 `add()`와 `work()`의 함수 정의, 바디를 복사
  3. `add()` 함수의 정의와 바디가 main.cpp에 중복 복사됨  

    ```cpp
    // 컴파일 시 내부적으로 아래와 같은 상황이 됨

    int add (int x, int y ) // 바디가 두번 복사됨
    {
      return x + y;
    }
    int add (int x, int y ) // 바디가 두번 복사됨
    {
      return x + y;
    }
    void work()
    {
      add(1, 2); 
    }
    int main()
    {
      cout << add(3, 4) << endl;
      work();
    }
    ```

**헤더 가드 종류**  

1. `#ifndef`, `endif`
   - `#ifndef`
     - 이미 정의되어 있지 않다면(아직 include되지 않은 부분이라면)
   - `endif`
     - `#ifndef`부터 `#endif`까지 이 범위의 복사를 허용  

    ```cpp
    #ifndef MY_ADD
    #define MY_ADD

    int add(int a, int b)
    {
      return a + b;
    }
    #endif
    ```

2. `#pragma once`
   - 헤더 파일 전체의 재정의를 막음
   - C++ 공식 표현이 아니므로 모든 컴파일러가 지원하지 않음
   - 지원하지 않는 컴파일러라면 `#ifndef`, `#endif`를 사용  

    ```cpp
    #pragma once

    int add(int a, int b)
    {
      return a + b;
    }
    ```
