---
title: "[C++] Chapter 12.6 가상 함수 테이블"
date: 2025-11-04 14:06:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 108
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 함수 : 가상 함수 테이블

### 가상 함수 테이블

---

- 가상 함수가 선언되면 가상 함수 테이블을 만들고 동적 바인딩을 함
  - 이때 클래스는 가상 함수 테이블에 대한 포인터를 갖게 됨

![이미지1](https://imgur.com/9cyqO8w.png)

- `Base` 클래스에서 `fun1()`, `fun2()` 2개의 가상 함수가 선언되었고 `Base` 타입 객체를 생성하면 그와 동시에 가상 함수 테이블과 가상 함수 테이블의 포인터가 생성됨
    1. 가상 함수 포인터 `*_vptr`을 보고 가상 함수 테이블을 찾아감
    2. 가상 함수 테이블에서 가상 함수의 포인터를 받아옴
    3. 받아온 주소를 통해 가상 함수 실행

![이미지2](https://imgur.com/dpNsju3.png)

- 자식 클래스에도 그대로 가상 함수 테이블의 포인터가 상속됨
    1. 상속 받은 가상 함수 포인터 `*_vptr`을 보고 가상 함수 테이블을 찾아감
    2. 가상 함수 테이블에서 가상 함수의 포인터를 받아옴
    3. 오버라이딩된 `fun1()`을 실행하고, `fun2()`는 `Base`의 `fun2()`를 실행함

### 클래스 크기 비교

---

- 가상 함수를 가지는 클래스는 가상 함수 포인터를 추가로 가지기 때문에 클래스 크기가 더 큼

**가상 함수가 없을 때**  

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
    void fun1() {};
    void fun2() {};
};

class Derived : public Base
{

};

int main()
{
    cout<< sizeof(Base) << endl;    // 1 출력
    cout<< sizeof(Derived) << endl;     // 1 출력

    return 0;
}
```

**가상 함수가 있을 때**  

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
    virtual void fun1() {};
    virtual void fun2() {};
};

class Derived : public Base
{

};

int main()
{
    cout<< sizeof(Base) << endl;    // 4 출력
    cout<< sizeof(Derived) << endl;     // 4 출력

    return 0;
}
```
