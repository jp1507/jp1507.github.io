---
title: "[C++] Chapter 14.6 예외 처리의 위험성과 단점"
date: 2025-11-03 15:18:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 127
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 14. 예외처리 : 예외 처리의 위험성과 단점

### 1. 메모리 누수가 발생할 수 있음

---

```cpp
#include <iostream>
using namespace std;

int main()
{
    try
    {
        int* i = new int[1000000];
        throw "error";

        delete[] i;
    }
    catch (...)
    {
        cout << "Catch" << endl;
    }
    return 0;
}
```

- 만약 `throw "error"`가 발생하면 아래의 `delete`가 실행되지 못하고 바로 `catch`로 넘어가기 떄문에 할당 해제되지 못하고 메모리 누수가 발생함

**스마트 포인터**  

- `#include <memory>`
- `unique_ptr` 스마트 포인터를 사용하면 메모리 누수를 방지할 수 있음
- 해당 블록을 벗어나면 스마트 포인터가 알아서 동적 할당 받은 부분을 지워줌

```cpp
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    try
    {
        int* i = new int[1000000];
        unique_ptr<int> up_i(i);

        throw "error";
    }
    catch (...)
    {
        cout << "Catch" << endl;
    }
    return 0;
}
```

### 2. 소멸자 내에 예외를 던지면 안됨

---

- 소멸자는 해당 객체의 메모리를 날려버리는 순간 호출되는 것이기 때문에 정상적으로 예외를 던질 수 있는 상태로 보지 않음
- 따라서 소멸자 내에 예외를 던지는 것은 위험하며 런타임 에러가 발생함

```cpp
#include <iostream>
using namespace std;

class A
{
public:
    ~A()
    {
        throw "error"; // Error !!!
    }
};

int main()
{
    try
    {
        A a;
    }
    catch (...)
    {
        cout << "Catch" << endl;
    }
    return 0;
}
```

### 3. 루프 내에 try-catch문을 넣는 것은 지양해야 함

---

- `try-catch`문은 여러 스택을 왔다갔다하기 때문에 연산이 느림
- 가장 많이 사용되는 루프 내에 `try-catch`를 넣으면 매우 느려질 수 있으므로 가급적 루프 바깥에서 사용

### 4. 모든 오류를 예외 처리로 잡으려 하지 않기

---

- 오류와 예외는 다름
- 정상적으로 작동 해야하는 것은 성능을 위해 예측 가능한 경우 `if`문으로 걸러내는 것이 좋음
- 분산 처리, 네트워크 문제 등 예측할 수 없는 경우 고장의 원인이 됨
  - 논리적으로 예측이 어려운 경우엔 예외를 쓰는 것이 좋음
