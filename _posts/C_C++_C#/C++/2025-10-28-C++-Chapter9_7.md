---
title: "[C++] Chapter 9.7 첨자 연산자 오버로딩"
date: 2025-10-28 14:42:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 83
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : 첨자 연산자 오버로딩

- 첨자 연산자 : `[]`

### 연산자 오버로딩을 사용하지 않은 경우

---

```cpp
#include <iostream>
using namespace std;

class IntList
{
private:
    int m_list[10];
public:
    void SetItem(int index, int value) { m_list[index] = value; }
    int GetItem(int index) { return m_list[index]; }
    int* GetList() { return m_list; }
};

int main()
{
    IntList my_list;

    my_list.SetItem(3, 1);
    cout << my_list.GetItem(3) << endl;
    my_list.GetList()[3] = 1;   // 포인터로 array를 꺼낸 뒤에 값을 수정
    cout << my_list.GetList()[3] << endl;
    return 0;
}
```

- `private` 멤버인 `m_list`의 원소에 접근하기 위해 접근 전용 멤버 함수를 구현해야 함

### 멤버 함수로 구현

---

- 함수를 거치지 않고 `[index]`만으로도 해당 객체의 배열 멤버에 접근할 수 있도록 `[]` 연산자를 오버로딩함
  - `[]` 연산자 오버로딩은 **멤버 함수로만 구현 가능**

```cpp
#include <iostream>
using namespace std;

class IntList
{
private:
    int m_list[10];
public:
    int& operator [](const int index) 
    {
        return m_list[index];
    }
};

int main()
{
    IntList my_list;

    my_list[3] = 10;
    cout << my_list[3] << endl;

    return 0;
}
```

### 배열 읽기만 가능하게 구현

---

```cpp
#include <iostream>
using namespace std;

class IntList
{
private:
    int m_list[10] = { 1, 2 ,3, 4, 5, 6, 7, 8, 9 , 10 };
public:
    int& operator [](const int index)
    {
        return m_list[index];
    }
    const int& operator [](const int index) const
    {
        return m_list[index];
    }
};

int main()
{
    const IntList my_list;

    my_list[3] = 10;    // Error !!!
    cout << my_list[3] << endl;

    return 0;
}
```

### 런타임 에러 방지

---

```cpp
#include <iostream>
#include <cassert>
using namespace std;

class IntList
{
private:
    int m_list[10] = { 1, 2 ,3, 4, 5, 6, 7, 8, 9 , 10 };
public:
    int& operator [](const int index) 
    {
        assert(index >= 0);
        assert(index < 10);

        return m_list[index];
    }
    const int& operator [](const int index) const 
    {
        assert(index >= 0);
        assert(index < 10);

        return m_list[index];
    }
};

int main()
{
    const IntList my_list;
    cout << my_list[3] << endl;
    return 0;
}
```

- 배열 인덱스를 음수 혹은 배열의 크기를 넘는 인덱스를 인수로 넘기지 않고 미리 `assert`로 설정해 에러를 발생하게 함

### 포인터 객체를 사용할 때 주의

---

```cpp
InList* list = new InList;

list[3] = 10;   // Error !!!
(*list)[3] = 10;
```

- 객체를 동적으로 할당 받아 포인터로 참조할 때, `list[3]`이 아닌 `(*list)[3]`로 접근해야 함
