---
title: "[C++] Chapter 9.10 복사 생성자, 복사 생략, 리턴값 최적화"
date: 2025-10-28 15:22:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 86
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : 복사 생성자, 복사 생략, 리턴값 최적화

### 복사 생성자

---

- 어떤 객체를 복사하여 같은 타입의 객체를 생성할 때 호출

```cpp
Fraction(const Fraction &fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator)
{ 
    cout << "Copy constructor called" << endl; 
}
```

- 복사 생성자는 복사할 대상을 인수로 받아 멤버 변수 값들을 전부 복사해 초기화함

**복사 생성자가 호출될 때**  

```cpp
#include <iostream>
#include <cassert>
using namespace std;

class Fraction
{
private:
    int m_numerator;
    int m_denominator;
public:
    Fraction(int num = 0, int den = 1) : m_numerator(num), m_denominator(den)
    {
        assert(den != 0);   // 분모가 0일 때
        cout << "Constructor" << endl; 
    }

    Fraction(const Fraction &fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator)
    { 
        cout << "Copy constructor" << endl; 
    }

    friend std::ostream& operator <<(std::ostream& out, const Fraction& f)
    {
        out << f.m_numerator << "/" << f.m_denominator << endl;
        return out;
    }
};

int main()
{
    Fraction frac(3, 5);
    Fraction fr_copy(frac);
    Fraction fr_copy2 = frac;

    cout << frac << " " << fr_copy << " " << fr_copy2 << endl;
    // 3/5 3/5 3/5 출력

    return 0;
}
```

- `Fraction fr_copy(frac);`
  - `fr_copy`는 자기 자신과 같은 타입인 frac객체를 인수로 받아 생성되는 객체
  - 복사 생성자가 호출되어 `frac`의 멤버 값들을 자신의 멤버에 복사함
- `Fraction fr_copy2 = frac;`
  - 초기화로 대입할 때도 복사 생성자가 호출됨

**복사 과정이 생략될 때**  

```cpp
Fraction fr_copy2(Fraction(3, 10));
// Constructor 출력
```

- `Fraction(3, 10)`은 R-Value 익명 객체로, 이 객체의 생성자와 `fr_copy2`의 복사 생성자 총 2번 호출되어야 하는데 실제로는 복사 과정이 생략되어 `Fraction(3, 10)`의 일반 생성자가 호출됨
- 컴파일러가 불필요하게 생성자가 많이 호출되는 것을 방지하기 위해 복사 생성을 수행하지 않고 `fr_copy2`가 `Fraction(3, 10)`의 메모리를 곧바로 참조하게 만듦
- 이처럼 복사할 대상이 R-Value 객체일 때 컴파일러가 복사 과정을 생략하기도 함
  - 복사 과정을 생략할지 컴파일러가 판단하며 항상 그러한 것은 아님
  - C++ 17 이상부터 함수 내부에 객체를 만들어 리턴하는 경우 등 일부 경우에 대해 반드시 복사를 생략한다고 함

**복사 생성자 호출을 방지하고 싶은 경우**  

- 복사 생성자를 `private`으로 정의할 경우 호출되지 않음

```cpp
private:
    Fraction(const Fraction &fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator)
    { 
        cout << "Copy constructor called" << endl; 
    }

...

Fraction f(frac);  // 복사 생성자 호출 안됨
Fraction f = frac; // 복사 생성자 호출 안됨
```

### 리턴값 최적화

---

- 임시 객체를 함수로 리턴받고 이를 복사 대상으로 하는 경우
  - 디버그 모드 : 복사를 하고 복사 생성자가 호출됨
  - 릴리즈 모드 : 복사를 생략하고 복사 생성자가 호출되지 않음

```cpp
Fraction DoSomething()
{
    Fraction temp(1, 2);
    cout << &temp << endl;
    return temp;
}

int main()
{
    Fraction result = DoSomething();
    cout << &result << endl;
}
```

- `DoSomething()`은 임시 객체 `temp`를 리턴하며 지역 변수이므로 리턴 후 사라짐
  - 디버그 모드
    - 복사 과정을 실행
    - `&temp`와 `&result`는 별개의 객체
  - 릴리즈 모드
    - 복사 과정을 생략
    - `&temp`와 `&result`는 동일 객체, 동일 메모리
