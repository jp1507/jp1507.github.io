---
title: "[C++] Chapter 6.6 포인터 기초"
date: 2025-10-22 15:08:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 33
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 포인터

---

- 메모리 주소를 담는 변수
- `&` : 변수 앞에 붙으면 그 변수의 주소 값을 의미
- `*` : 포인터 변수 앞에 붙으면 그 포인터 변수가 담고 있는 주소에 담긴 값
- 간접 참조

## 포인터 변수의 선언

---

- `Type * var;`

```cpp
int x = 5;
int* ptr = &x;  
*ptr = 7;  // x 값이 7로 변한다. x = 7
```

- `int* ptr = &x`
  - `int` 타입 변수의 주소를 갖는 포인터라는 뜻
  - `ptr`은 `int` 타입 변수인 `x`의 주소 값으로 초기화
  - 따라서 포인터 `ptr`은 `x`를 가리킴
- `*ptr = 7`
  - `x`의 주소를 가리키는 `ptr`에 `*`를 붙이면 `x`의 값을 참조
  - 포인터 선언 시 데이터 타입을 쓰는 이유는 간접 참조 시 어떤 데이터 타입으로 값을 참조할지 정보가 필요하기 때문

## 포인터를 사용하는 이유

---

- 많은 양의 데이터를 **복사**하려면 비용이 매우 비쌈
- 따라서 포인터로 간접 참조하거나 포인터에 주소를 두고 주소 정보만 복사하여 사용하면 효율적

## 포인터의 크기

---

- `sizeof(ptr)`를 이용해 알아볼 수 있음
- 32bit 시스템에서는 `int*`나 `double*`나 모두 크기는 4 byte
- 64bit 시스템에서는 `int*`나 `double*`나 모두 크기는 8 byte

## nullptr

---

- C 언어에선 `NULL`로 사용했고, C++에서는 `nullptr`로 쓰임
- 포인터 값이 없다는 의미로, 가리키고 있는 대상이 없음
- 어느 것도 가리키지 않는 포인터는 항상 `nullptr`로 초기화해야함
  - 조건문으로 `nullptr`인지 검사하여 작동을 제어
  - 포인터도 변수이기 때문에 쓰레기 값이 들어있으면 엉뚱한 주소를 가리켜 문제가 발생할 수 있음

**\<cstddef\>의 std::nullptr_t**  

```cpp
std::nullptr_t nptr;
```

- 이 타입으로 선언된 변수는 오직 `nullptr`만 담을 수 있음
