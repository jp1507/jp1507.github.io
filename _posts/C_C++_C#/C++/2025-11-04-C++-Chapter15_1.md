---
title: "[C++] Chapter 15.1 이동의 의미와 스마트 포인터"
date: 2025-11-04 13:21:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 128
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : 이동의 의미와 스마트 포인터

### 기존의 메모리 관리 방법

---

#### 1. RAII

- `new`로 메모리를 동적 할당 받은 곳에서 `return` 전 직접 프로그래머가 `delete`로 할당 해제해야 한다는 디자인 패턴
- 보통 클래스 내에 묶어두고 소멸자 내에 자원을 해제하는 `delete` 루틴을 넣는 디자인 패턴
- 따라서 일반 포인터가 아닌 포인터 객체로 만들어 자신이 소멸될 때 자신이 가리키는 데이터도 같이 `delete`되도록 코딩하는 것이 일반적

**문제가 생기는 경우**  

1. 실수로 프로그래머가 `delete`를 잊은 경우
2. `if_else`문에 걸려 `delete` 되기 전에 `return`되는 경우
3. `try-catch`문에서 `delete` 되기 전에 `throw` 전 `early return` 되어버리는 경우

```cpp
class Resource
{
public:
    int m_data[100];
public:
    Resource()
    {
        cout << "Resource constructed" << endl;
    }
    ~Resource()
    {
        cout << "Resource destroyed" << endl;
    }
};

void DoSomething()
{
    try 
    {
      Resurce* res = new Resurce;
      
      if (true)
        throw - 1; 
      
      delete res;
    }
    catch (...)
    {
    }
    return;
}

int main()
{
    DoSomething();
}
```

#### 2. 메모리를 자동으로 관리해주는 클래스 템플릿 사용

```cpp
class Resource
{
public:
    int m_data[100];
public:
    Resource()
    {
        cout << "Resource constructed" << endl;
    }
    ~Resource()
    {
        cout << "Resource destroyed" << endl;
    }
};

template<typename T>
class AutoPtr
{
public:
    T* m_ptr = nullptr;
public:
    AutoPtr(T* ptr = nullptr) : m_ptr(ptr) {}
    ~AutoPtr() 
    {
      if (m_ptr != nullptr) 
          delete m_ptr;
    }
    T& operator *() const { return *m_ptr; }
    T* operator ->() const { return m_ptr; }
    bool IsNull() const { return m_ptr == nullptr; }
};
```
```cpp
void DoSomething()
{
    try 
    {
      AutoPtr<Resource> res = new Resource;
      if (true)
        throw - 1;
    }
    catch (...)
    {
    }
    return;
}

int main()
{
    DoSomething();
}
```

- 스마트 포인터와 기능이 유사함
- `Class AutoPtr`
  - 클래스 템플릿으로 포인터처럼 작동되도록 구현함
  - 소멸자에서 `nullptr`이 아니면 메모리를 지워주도록 되어있음
- `AutoPtr<Resource> res = new Resource;`
  - `res`는 `Resource` 타입의 포인터처럼 사용할 수 있음
  - 중간에 early return 되더라도 알아서 할당 해제해줌

**문제가 생기는 경우**  

```cpp
int main()
{
  {
    AutoPtr<Resource> res1(new Resource);
    AutoPtr<Resource> res2;

    cout << res1.m_ptr << endl;
    cout << res2.m_ptr << endl;

    res2 = res1;

    cout << res1.m_ptr << endl;
    cout << res2.m_ptr << endl;
  }
}
```
```text
- 출력 -

Resource constructed
0014FFA8
00000000
0014FFA8
0014FFA8
Resource destroyed
Resource destroyed
```

- `res2`가 `nullptr`을 담고 있는 상태에서 `res2 = res1`에서 같은 `Resource` 타입 객체를 가리키게 되고 `res1` 객체가 소멸될 때 할당 해제시켰음에도 `res2`에서 다시 할당 해제하려고 하니까 런타임 에러가 발생함

### 해결법 : 소유권 이동(move semantics)

---

- 객체 소유권을 박탈하고 넘겨(Move)주어야 함
- 소유권 이동을 구현할 때 아래 두 가지 중 하나를 고려해야 함
    1. 복사 생성자
    2. 대입 연산자 오버로딩

```cpp
#include <iostream>
using namespace std;

template<typename T>
class AutoPtr
{
public:
    T* m_ptr= nullptr;
public:
    AutoPtr(T* ptr = nullptr) : m_ptr(ptr) {}
    ~AutoPtr()
    {
        if(m_ptr != nullptr) 
            delete m_ptr;
    }

    AutoPtr(AutoPtr& a)
    {
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;
    }

    AutoPtr& operator =(AutoPtr& a)
    {
        if (&a == this)
            return *this;
        
        delete m_ptr;
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;

        return *this;
    }

    T& operator *() const { return *m_ptr; }
    T* operator ->() const { return m_ptr; }
    bool IsNull() const { return m_ptr == nullptr; }
};
```

- 대입 연산자 오버로딩
  - 대입되는 것이 자기 자신일 경우 자기 자신을 반환
  1. 이미 담고 있는 것을 할당 해제
  2. 인수로 전달받은 주소를 대입
  3. 인수의 소유권 박탈
- 복사 생성자
  - 자신을 새로 생성시킬 때 기존의 다른 객체로부터 복사되어 생성되는 경우 호출
  - 대입 연산자 오버로딩과 다르게 이미 담고 있는 것을 지울 필요 없고, 복사된 것이 자기 자신인 경우를 고려할 필요가 없음
  1. 인수로 전달받은 주소를 대입
  2. 인수의 소유권 박탈

### Semantics vs. Syntax

---

- Syntax : 문법에 맞는지, 컴파일이 되는지
- Semantics : 컴파일 되더라도 프로그래머가 의도한 의미대로 동작하는지
  1. value semantics (copy semantics)
  2. reference semantics (pointer)
  3. move semantics
