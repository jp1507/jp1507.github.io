---
title: "[C++] Chapter 9.4 단항 연산자 오버로딩"
date: 2025-10-28 13:52:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 80
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : 단항 연산자 오버로딩

- 단항 연산자 : `+`, `-`, `!`

### 전역 함수로 구현

---

```cpp
#include <iostream>
using namespace std;

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents = 0) { m_cents = cents; }

    friend std::ostream& operator <<(std::ostream& out, const Cents& cents)
    {
        out << cents.m_cents;
        return out;
    }

    friend Cents operator -(const Cents& c)
    {
        return Cents(-c.m_cents);
    }
};


int main()
{
    Cents cents1(6);

    cout << cents1 << endl;   // 6 출력 
    cout << -cents1 << endl;    // -6 출력
    cout << -Cents(-10) << endl;    // 10 출력(익명 객체)

    cout << cents1 << endl;   // 6 출력 

    return 0;
}
```

- 단항 연산자는 피연산자를 1개 필요로 함
  - 전역 함수로 구현하므로 인수 1개를 설정
- 전역 함수이므로 뒤에 `const`가 붙을 수 없음

### 멤버 함수로 구현

---

```cpp
#include <iostream>
using namespace std;

class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }
    int GetCents() const { return m_cents; }
    int& GetCetns() { return m_cents; }

    bool operator ! () const  
    {
        return (m_cents == 0) ? true : false;
    }

    friend std::ostream& operator <<(std::ostream& out, const Cents& cents)
    {
        out << cents.m_cents;
        return out;
    }
};

int main()
{
    Cents cents2(0);
    cout << !cents2 << endl;    // 1 출력

    return 0;
}
```

- 단항 연산자는 피연산자를 1개 필요로 하는데 멤버 함수로 구현하면 인수를 받을 필요가 없음
  - 자기 자신이 피연산자가 되기 때문
- 뒤에 `const`를 붙여 멤버 값을 수정하지 않겠다는 명시
