---
title: "[C++] Chapter 2.4 부동소수점수"
date: 2025-10-17 14:48:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 9
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 부동소수점수

---

| 데이터 형   | 최소 크기 | 전형적인 크기 |
| ----------- | --------- | ------------- |
| float       | 4 byte    | 4 byte        |
| double      | 8 byte    | 8 byte        |
| long double | 8 byte    | 4 byte        |

## float 내부

---

$0000011111000000000000000000000_{(2)}$를 실수 변환

$$0 0000111 11000000000000000000000 = +1.313554 * 10^{-36}$$

- `float`
  - 4 byte = 32 bits = 총 32자리
- 부호비트
  - 1자리
  - 0이므로 +(양수)
  
$$ 00000111 = 2^0 + 2^1 + 2^2 = 7$$

- 지수 비트
  - 8자리
  - 00000111
  - 십진수로 7

$$ 11000000000000000000000 = 2^{-1} + 2^{-2} = 0.5 + 0.25 = 0.75$$

- 가수 비트
  - 23자리
  - 왼쪽부터 $2^{-1}-1$이며 소수 자리를 나타냄
  - 십진수로 0.75

$$ +(1 + 0.75) * 2^{7-127} = +1.313554 * 10^-36 $$

- $(1 + 0.75)$
  - 가수 비트 십진수 값에 1 더해주기
- $2^{7-127}$
  - 지수 비트 십진수 값에 127을 빼주는 이유는 32bit 기준으로 메모리 값을 저장할 때 따르는 규칙

## std::numeric_limits<Type>::lowest()

---

- min : 가장 작은 **절대값**
- lowest : 가장 작은 값, 음수일 수도 있음
- 각각 `float`, `double`, `long double`이 표현할 수 있는 범위 중 가장 작은 값 리턴

```cpp
cout << numeric_limits<float>::lowest() << endl;
cout << numeric_limits<double>::lowest() << endl;
cout << numeric_limits<long double>::lowest() << endl;
```

## 실수의 다양한 표현 방법

---

- `float f(3.14)`
  - C++ 문법으로, `double`형인 3.14를 `float`으로 자동 형변환해 저장
  - `float f{3.14}`은 엄격한 형변환이므로 불가능

```cpp
float f(3.14)

cout << 3.14 << endl;
cout << 31.4e-1 << endl; // 3.14
cout << 31.4e-2 << endl; // 0.314
cout << 31.4e1 << endl; // 314
cout << 3.14e2 << endl; // 3140
```

## std::setprecision(n)

---

- `#include <iomanip>`
- 출력할 자리 수를 지정함

```cpp
cout << setprecision(16) << endl;
cout << 1.0 / 3.0 << endl;
```

- `cout << setprecision(16) << endl;`
  - 출력 스트림에 16자리까지 보장하도록 설정
- `cout << 1.0 / 3.0 << endl;`
  - `setprecision()`으로 16자리까지 출력하도록 했기 때문에 0.3333333333333333 출력

정밀도 차이가 지속해서 쌓이면 버그, 에러나 예측할 수 없는 문제가 발생할 수 있음

- 실수의 표현 원리
  - 이진수로 변환해 최대한 가깝게 표현
  - 0.25처럼 딱 떨어지는 이진수 소수라면 100% 정확하지만 0.1처럼 십진수 소수라면 이진수 합의 조합들로 최대한 0.1에 가깝게 만드는 것
  - 정확한 값과 차이가 존재하며 정밀도가 높을 수록 최대한 가깝게 만들 수 있음

```cpp
double d(0.1);

cout << d << endl;
cout << std::setprecision(17);
cout << d << endl;
```

- `cout << d << endl;`
  - 0.1을 출력
- `cout << std::setprecision(17);`
  - 출력 스트림에 16자리까지 출력되도록 설정
- `cout << d << endl;`
  - 0.1000000000000001
  - 17자리로 출력하면 끝자리에 1이 출력됨
  - 이진수들의 합으로 십진수인 0.1에 최대한 가깝게 만듦

```cpp
double d1(1.0);
double d2(0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);

cout << std::setprecision(17);
cout << d1 << endl;
cout << d2 << endl;
```

- `cout « d1 « endl;`
  - 17자리 모두 출력하지 않고 딱 떨어진 1 출력
- `cout « d2 « endl;`
  - 0.99999999999999999
  - 1.0이 아닌 0.99999999999999999 로 나오는 이유
    - 0.1들을 이진수로 변환 후 더해주기 때문
    - 이진수로 0.1은 딱 떨어지는 수가 아니기 때문에 이진수로 최대한 표현하다보니 차이가 생김
    - 모두 더하니 1.0에 가까워졌지만 딱 떨어지는 1.0은 아님
