---
title: "[C++] Chapter 8.6 소멸자"
date: 2025-10-27 15:11:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 67
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 8. 객체 지향의 기초 : 소멸자

### 소멸자

---

- 객체가 영역을 벗어나 메모리에서 해제될 때 자동으로 호출되는 함수
  - 생성자는 메모리를 차지할 때, 즉 객체가 생성될 때 호출되는 함수라는 점에서 차이

### 소멸자가 호출되는 과정

---

- 소멸자는 `~클래스이름()`으로 정의
  - 매개변수를 받지 않음
- 소멸자는 자동으로 호출되는 함수이며 개발자가 직접 호출하는 것은 권장하지 않음

```cpp
#include <iostream>

using namespace std;

class Simple
{
private:
    int m_id;
public:
    Simple(const int& id_in) : m_id(id_in)
    {
      cout << "constructor" << m_id << endl;
    }
    ~Simple() 
    {
      cout << "Destructor" << m_id << endl;
    }
};

int main()
{
    Simple s1(0);
    Simple s2(1);

    return 0;
}
```

- `main()` 함수의 `return 0;`가 실행되면 객체 `s1`, `s2`의 메모리가 반납되면서 소멸자가 자동 호출 됨
- 가장 나중에 만들어진 객체가 먼저 사라지므로 `s2`의 소멸자가 먼저 호출되어 *"Destructor 1"*이 처음 출력됨
  - 스택 메모리를 사용하기 때문에 선입후출

### 소멸자 활용 방법

---

- 메모리를 동적 할당 받은 멤버가 있을 때 소멸자 안에서 이 멤버를 할당 해제하여 메모리 누수를 방지할 수 있음

```cpp
#include <iostream>
using namespace std;

class IntArray
{
private:
    int *m_arr = nullptr;
    int m_length = 0;
public:
    IntArray(const int& length_in)
    {
      m_length = length_in;
      m_arr = new int[m_length];
      cout << "constructor" << endl;
    }
    ~IntArray()
    {
        delete [] m_arr;
    }

    int getLength() { return m_length; }
};

int main()
{
    while (true) 
      IntArray my_int_arr(10000);

    return 0;
}
```

- 객체 생성 시 `m_arr` 멤버는 동적 할당 받는데, 이 경우에 개발자가 실수로 할당 해제시키지 않는다면 객체가 무한으로 생성하는 무한 루프 때문에 메모리 누수가 생김
- 소멸자에서 `m_arr`를 할당 해제 시키는 코드를 삽입하면 다음 반복으로 넘어갈 때 객체가 소멸되면서 소멸자로 `m_arr`의 메모리가 할당 해제될 것임
