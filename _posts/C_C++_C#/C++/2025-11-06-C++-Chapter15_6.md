---
title: "[C++] Chapter 15.6 std::shared_ptr"
date: 2025-11-06 13:00:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 132
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : std::shared_ptr

### std::shared_ptr

---

- 객체에 대한 소유권을 나눠주고 공유함
- `unique_ptr`과 달리 여러 `shared_ptr`이 한 객체에 대해 동시에 공유할 수 있도록 함
- 소유권을 느슨하게 관리할 때 사용하며, `shared_ptr`은 내부적으로 자신이 가리키고 있는 객체가 몇 군데에서 공유되고 있는지 항상 세고 있음

**소유권 분배가 제대로 이루어졌을 때**  

```cpp
#include <iostream>
#include <memory>

int main()
{
    Resource* res = new Resource(3);
    res->SetAll(1);

    std::shared_ptr<Resource> ptr1(res);
    ptr1->Print();

    {
        std::shared_ptr<Resource> ptr2(ptr1);
        ptr2->SetAll(5);
        ptr2->Print();
        std::cout << "Going out of the block" << std::endl;
    }

    ptr1->Print();
    std::cout << "Going out of the block" << std::endl;

    return 0;
}
```
```text
- 출력 -

Resource length constructed
1 1 1
5 5 5
Going out of the block
5 5 5
Going out of the block
Resource destroyed
```

- `std::shared_ptr<Resource> ptr2(ptr1);`
  - `ptr1`이 가리키고 있던 `Resource` 객체의 소유권을 `ptr2`에게도 분배함
  - `ptr1`과 `ptr2`가 동일한 객체를 가리키게 되며 동시에 소유권을 가짐
- `ptr1`에게도 소유권이 있다는 것을 `ptr2`도 알고 있음
  - 따라서 `ptr2`가 할당 해제되더라도 여전히 `ptr1`과 함께 소유했던 그 객체는 사라지지 않음
  - `ptr1`과 `ptr2`가 `unique_ptr`이라면 `ptr2`가 사라짐과 동시에 객체도 할당 해제됐을 것임
  - 객체의 유일한 소유권자가 사라질 때 그제서야 할당 해제됨

**소유권 분배가 제대로 이루어지지 않았을 때**  

```cpp
int main()
{
    Resource* res = new Resource(3);
    res->SetAll(1);

    std::shared_ptr<Resource> ptr1(res);
    ptr1->Print();

    {
        std::shared_ptr<Resource> ptr2(res); 
        ptr2->SetAll(5);
        ptr2->Print();
        std::cout << "Going out of the block" << std::endl;
    }

    ptr1->Print();    // Error !!!
    std::cout << "Going out of the block" << std::endl;

    return 0;
}
```
```text
- 출력 -

Resource length constructed
1 1 1
5 5 5
Going out of the block
Resource destroyed
```

- `ptr1`과 `ptr2`가 `res`라는 동일한 객체를 가리키고 소유하지만 둘 다 `res`에 대한 소유권이 있는 상태라는 것을 서로 알 수가 없음
- 따라서 `ptr2`가 할당 해제되면 `res` 객체까지 해제되기 때문에 `ptr1->Print();`에서 런타임 에러가 발생함
- `shared_ptr` 포인터 선언시 객체에 대해 정의할 것이라면 `ptr2 = ptr1`과 같이 복사 방식을 통해 둘 다 동일한 객체에 대해 소유권을 공유하고 있음을 서로에게 알려주어야 함

### std::shared_ptr 함수들

---

**std::make_shared 함수**  

- 객체를 생성함과 동시에 이를 소유하는 `shared_ptr`을 리턴함
- 이 함수를 통해 객체 생성과 동시에 스마트 포인터를 생성하는 것이 권장됨

```cpp
std::shared_ptr<Resource> ptr1 = std::make_shared<Resource>(3);
std::shared_ptr<Resource> ptr2 = ptr1;

auto ptr1 = std::make_shared<Resource>(3);       
auto ptr2 = ptr1; 
```

**use_count(), reset() 함수**  

- `use_count()` : 어떤 객체를 소유하고 있는 `shared_ptr`들이 총 몇 개인지 리턴
- `reset()` : 해당 `shared_ptr` 포인터 객체에 대한 소유권을 박탈함

```cpp
std::shared_ptr<Resource> ptr1 = std::make_shared<Resource>(3);
cout << "현재 소유자 수 : " << ptr1.use_count() << endl; // 1 출력

auto ptr2 = ptr1;
cout << "현재 소유자 수 : " << ptr1.use_count() << endl; // 2 출력

ptr2.reset();
cout << "현재 소유자 수 : " << ptr1.use_count() << endl; // 1 출력
```

### std::shared_ptr의 문제점

---

1. 순환 참조
   - 그룹 객체와 소속 객체 사이에서 발생하는 순환 참조
   - 서로가 서로를 참조하는 순환 참조가 가능한데 이런 상황에서는 메모리 해제가 정상적으로 되지 않음
2. 멀티 스레드 안정성
   - 다수의 스레드에서 같은 객체를 참조하는 경우 읽기는 안전하지만 쓰기는 안전하지 않음
