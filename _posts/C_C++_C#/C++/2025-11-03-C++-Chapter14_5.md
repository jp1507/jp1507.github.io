---
title: "[C++] Chapter 14.5 함수 try"
date: 2025-11-03 15:09:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 126
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 14. 예외처리 : 함수 try

### 함수 try 사용 전

---

```cpp
#include <iostream>
#include <exception>

class A
{
private:
    int m_x;
public:
    A(int x) : m_x(x)
    {
        if (x == 0)
            throw 1;
    }
};

class B : public A
{
public:
    B(int x) : A(x) {}
};

int main()
{
   try
   {
      B b(0);
   }
   catch (...)
   {
      std::cout << "Catch in main()" << std::endl;
   }
   
   return 0;
}
```
```text
- 출력 -

Catch in main()
```

- `main()`에서 `B b(0);`으로 `B`의 생성자에서 부모인 `A`의 생성자를 호출하고 `x`가 0이므로 예외 1을 `throw`함
- 이때 `A`의 생성자에서 발생한 예외를 `main()`이 아닌 `B`의 생성자에서 바로 `catch` 할 수 없음

### 함수 try 사용 후

---

```cpp
#include <iostream>
#include <exception>

class A
{
private:
    int m_x;
public:
    A(int x) : m_x(x)
    {
        if (x == 0)
            throw 1;
    }
};

class B : public A
{
public:
    B(int x) try : A(x) {}

    catch(...)
    {
        std::cout << "Catch in B constructor" << std::endl;
    }
};

int main()
{
   try
   {
      B b(0);
   }
   catch (...)
   {
      std::cout << "Catch in main()" << std::endl;
   }
   
   return 0;
}
```
```text
- 출력 -

Catch in B constructor
Catch in main()
```

- `B(int x) try`로 `B(int x)` 함수 전체가 `try`로 묶인 효과를 가짐
- `B` 생성자 바로 아래에 `catch(...)`에서 `A` 생성자에서 발생한 예외를 스택 되감기를 통해 받게 됨
  - 이 `catch(...)` 내에 `throw`를 명시하지 않았음에도 시스템 상으로 다시 한번 더 `throw`가 던져져 `main()` 함수의 `catch(...)`가 받게 됨

**함수 try 특징**  

1. 함수 하나를 통째로 `try`로 묶음
2. 함수 `try`의 예외를 받은 `catch`에선 명시되어있지 않아도 한번 더 예외를 `throw`함
