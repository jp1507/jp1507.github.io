---
title: "[C++] Chapter 9.1 연산자 오버로딩 시작하기"
date: 2025-10-28 13:02:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 77
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : 연산자 오버로딩 시작하기

### 연산자 오버로딩

---

```cpp
int main()
{
    out << 1 + 3 << endl; 
    cout << 1 * 3 << endl;

    int a = 3;
    cout << ++a << endl;
}
```

```cpp
class A
{
public:
    int data_a = 3;
    int data_b = 10;
};

int main()
{
    A obj1;
    A obj2;

    cout << obj1 + obj2 << endl;    // Error !!!
}
```

- `int`, `float`, `bool`과 같은 기본 자료형은 피연산자로서 C++에서 제공하는 연산자로 연산시킬 수 있음
- `A` 클래스 타입 두 객체 간 연산은 연산자로 연산하려면 에러가 발생함
  - 여러 멤버 변수들을 담고 있으므로 어떻게 덧셈해야할지 알 수 없음

```cpp
int operator +(const A & a, const A & b)
{
    return a.data_a + b.data_a;
}

class A
{
public:
    int data_a = 10;
};

int add(const A & a, const A & b)
{
    return a.data_a + b.data_a;
}

int main()
{
    A obj1;
    A obj2;

    cout << add(obj1, obj2) << endl;    // 20 출력
}
```

- 위와 같이 두 피연산자를 `A` 클래스 타입의 객체로 받는 덧셈 연산자(`+`)를 정의할 수 있음
- C++에서 `+`, `-`, `<<`, `[]` 등 연산자에 특정 타입의 객체가 피연산자로 들어올 때 어떤 연산을 하게끔 미리 정의할 수 있으며 이를 **연산자 오버로딩**이라고 함

### 연산자 오버로딩할 수 있는 연산자

---

- 새로운 연산자를 정의할 수는 없고 C++에서 제공하는 기본 연산자들만 오버로딩할 수 있음

1. 산술 연산자
   - 피연산자 2개 필요
   - `+`, `-`, `*`, `/`, `%`
   - `+=` 같은 복합 연산자
2. 입출력 연산자
   - 피연산자 2개 필요
   - `<<`, `>>`
3. 단항 연산자
   - 피연산자 1개 필요
   - `+`, `-`, `!`
4. 비교 연산자
   - 피연산자 2개 필요
   - `>=`, `==`, `>`, `!=`
5. 증감 연산자
   - 피연산자 1개 필요
   - `++`, `--`
6. 첨자 연산자
   - 피연산자 2개 필요
   - `[]`
7. 괄호 연산자
   - 피연산자 2개 필요
   - `()`
8. 논리 연산자
   - 피연산자 2개 필요
   - `&&`, `||`
9. 멤버 선택 연산자
   - `->`, `*`
10. 형변환 연산자
    - `(자료형)`, `자료형()`
11. 대입 연산자
    - `=`
12. 비트 연산자
    - `<<`, `>>`
    - `&`, `|`, `^`
13. 포인터 관련 연산자
    - `*`, `&`, `->`, `->*`
14. 메모리 연산자
    - `new`, `new[]`, `delete`, `delete[]`

### 연산자 오버로딩할 수 없는 연산자

---

- 아래 연산자들은 오버로딩이 불가능함

1. 조건 연산자
   - `?:`
2. 범위 지정 연산자
   - `::`
3. 크기 연산자
   - `sizeof`
4. 멤버 선택 연산자
   - `.`
5. 포인터 관련 연산자
   - `.*`

### 일반 전역 함수로 오버로딩

---

```cpp
class A
{
public:
    int data = 10;
};

int operator + (const A & a, const A & b)
{
    return a.data + b.data;
}

int main()
{
    A obj1;
    A obj2;

    cout << obj1 + obj2 << endl;    // 20 출력
}
```

```cpp
class Cents
{
public:
    int m_cents;
    Cents(int cents = 0) { m_cents = cents; }
};

void operator + (const Cents& c1, const Cents& c2) 
{
    cout << c1.m_cents + c2.m_cents << endl;
}

int main()
{
    Cents cents1(5);
    Cents cents2(7);

    cents1 + cents2;    // 12 출력
}
```

**전역 함수 사용시 접근하려는 멤버가 `private`일 때 : `friend` 사용하기**  

```cpp
class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }
    int GetCents() const { return m_cents; }
    int& GetCents() { return m_cents; }
};

void operator +(const Cents& c1, const Cents& c2)
{
    // private 멤버를 사용 불가능
    cout << c1.GetCents() + c2.GetCents() << endl;
}

int main()
{
    Cents cents1(5);
    Cents cents2(7);

    cout << cents1.GetCents() + cents2.GetCents() << endl;

    cents1 + cents2;
}
```

- `m_cents`가 `private` 멤버기 때문에 전역 함수에서는 접근하여 사용할 수 없음
- `+` 연산자 오버로딩 내의 `GetCents()`는 `int GetCents() const` 함수
- `main()` 함수의 `GetCents()`는 `int& GetCents()`

```cpp
class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }
    int GetCents() const { return m_cents; }
    int& GetCents() { return m_cents; }

    friend void operator +(const Cents& c1, const Cents& c2);
};

void operator + (const Cents & c1, const Cents & c2)
{
    cout << c1.m_cents + c2.m_cents << endl;
}

int main()
{
    Cents cents1(5);
    Cents cents2(7);

    cout << cents1.GetCents() + cents2.GetCents() << endl;

    cents1 + cents2;
}
```

- 전역 함수인 `+` 연산자 오버로딩을 `friend`로 지정하면 전역 함수 내에서 `private` 멤버인 `m_cents`에 접근 가능

```cpp
friend void operator +(const Cents& c1, const Cents& c2);

class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }
    int GetCents() const { return m_cents; }
    int& GetCents() { return m_cents; }

    friend void operator +(const Cents& c1, const Cents& c2)
    {
        cout << c1.m_cents + c2.m_cents << endl;  
    }
};
```

- 연산자 오버로딩이 클래스 내에서 구현되어 있어 멤버 함수라고 생각할 수 있지만 **전역 함수**임
  - `friend`로 지정할 때 바디를 같이 구현한 것일 뿐
- 이처럼 `friend + 함수 프로토타입`으로 하고 바디를 전역 범위에 정의하거나 클래스 내에 `friend + 함수 바디`를 정의할 수도 있음

### 멤버 함수로 오버로딩

---

- 왼쪽 피연산자가 멤버 함수를 호출하는 객체가 되고, 오른쪽 피연산자는 인수가 됨

```cpp
class A
{
private:
    int data = 10;

public:
    int operator +(const A& a)
    {
        return data + a.data;
    }
};

int main()
{
    A obj1, obj2;
    cout << obj1 + obj2 << endl;    // 20 출력
}
```

- 멤버 함수이기 때문에 피연산자가 2개 필요하더라도 매개변수 1개만 필요
  - 나머지 하나는 자기 자신(`this`)로 사용하면 되기 때문
- 멤버 함수이므로 `private` 멤버 변수들에 자유롭게 접근 가능

```cpp
class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }

    void operator +(const Cents& c2) 
    {
        cout << m_cents + c2.m_cents << endl;
    }
};

int main()
{
    Cents cents1(5);
    Cents cents2(7);

    cents1 + cents2;    // 12 출력
}
```

### 전역 함수와 멤버 함수 작동 비교

---

```cpp
cents1 + cents2 + cents3;
```

- 위 코드의 `+` 오버로딩이 전역 함수거나 멤버 함수일 때 어떻게 동작하는지 비교
  - 이때, 오버로딩된 연산자가 객체로 리턴해야 위와 같이 연쇄 호출 가능

**전역 함수**  

```cpp
class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }
    friend Cents operator +(const Cents& c1, const Cents& c2);  
};

Cents operator +(const Cents& c1, const Cents& c2)
{
    return Cents(c1.m_cents + c2.m_cents); 
}
```

1. `cents1 + cents2`
   - `Cents` 타입 두 매개변수를 받아 오버로딩된 `+` 연산을 실행하고 `Cents` 타입 객체를 리턴
2. `(cents1 + cents2) + cents3`
   - `cents1 + cents2` 결과와 `cents3` 두 객체를 매개변수로 받아 오버로딩된 `+` 연산을 실행하고 결과로 `Cents` 타입 객체를 리턴

**멤버 함수**  

```cpp
class Cents
{
private:
    int m_cents;
public:
    Cents(int cents = 0) { m_cents = cents; }
    Cents operator +(const Cents& c2) 
    {
        return Cents(m_cents + c2.m_cents); 
    }
};
```

1. `cents1 + cents2`
   - 자기 자신(`cents1`)과 인수(`cents2`)의 덧셈 결과를 `Cents` 타입 객체로 리턴
2. `(cents1 + cents2) + cents3`
   - 자기 자신(`cents1 + cents2`의 결과)과 인수(`cents3`)의 덧셈 결과를 `Cents` 타입 객체로 리턴

### 연산자 우선순위

---

- 연산자를 오버로딩해도 연산자의 우선순위는 그대로 유지됨
- 연산자 순위에 있어 모호한 경우 오버로딩 보단 기능을 일반 함수로 구현하는 것이 나음
