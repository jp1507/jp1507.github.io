---
title: "[C++] Chapter 15.7 std::weak_ptr"
date: 2025-11-07 13:22:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 133
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : std::weak_ptr

### shared_ptr의 순환 의존성 문제

---

```cpp
#include <iostream>
#include <memory>
#include <string>

class Person
{
private:
    std::string m_name;
    std::shared_ptr<Person> m_partner;
    //std::weak_ptr<Person> m_partner;
public:
    Person(const std::string& name) : m_name(name)
    {
        std::cout << m_name << " created\n";
    }

    ~Person()
    {
        std::cout << m_name << " destroyed\n";
    }

    friend bool PartnerUp(std::shared_ptr<Person>& p1, std::shared_ptr<Person>& p2)
    {
        if (!p1 || !p2)
          return false;
        
        p1->m_partner = p2;
        p2->m_partner = p1;

        std::cout << p1->m_name << " is partnered with " << p2->m_name << "\n";

        return true;
    }

    const std::string& GetName() const
    {
        return m_name;
    }
};
```

- `PartnerUp()` 함수에서 `Person` 객체를 소유하는 인수로 들어온 `shared_ptr`를 참조하는 `p1`과 `p2`가 서로를 서로의 파트너로 지정하고 있음
- `shared_ptr`이 서로가 서로를 참조할 때 소유권이 순환되어 영원히 두 객체를 할당 해제할 수 없는 문제인 순환 참조성 문제가 발생함
  - `use_count()` 값이 절대 0이 될 수 없으므로 영원히 해제되지 않음

```cpp
int main()
{
    auto lucy = std::make_shared<Person>("Lucy");
    auto ricky = std::make_shared<Person>("Ricky");

    return 0;
}
```
```text
- 출력 -

Lucy created
Ricky created
Ricky destroyed
Lucy destroyed
```

- 위와 같이 `PartnerUp()` 함수를 실행하지 않을 때에는 정상적으로 할당 해제가 되는 것을 볼 수 있음

```cpp
int main()
{
    auto lucy = std::make_shared<Person>("Lucy");
    auto ricky = std::make_shared<Person>("Ricky");
    
    PartnerUp(lucy, ricky);

    return 0;
}
```
```text
- 출력 -

Lucy created
Ricky created
Lucy is partnered with Ricky
```

- `PartnerUp()` 함수로 인해 서로를 참조하게 되어 문제가 발생함
- 블록 밖을 벗어나거나 프로그램 종료시 참조 개수가 0이 될 수 없어 할당 해제되지 않고 메모리 누수가 발생함

### std::weak_ptr

---

- `shared_ptr`의 순환 의존성 문제를 해결해줌

```cpp
#include <iostream>
#include <memory>
#include <string>

class Person
{
private:
    std::string m_name;

    //std::shared_ptr<Person> m_partner;
    std::weak_ptr<Person> m_partner;
public:
    Person(const std::string& name) : m_name(name)
    {
        std::cout << m_name << " created\n";
    }

    ~Person()
    {
        std::cout << m_name << " destroyed\n";
    }

    friend bool PartnerUp(std::shared_ptr<Person>& p1, std::shared_ptr<Person>& p2)
    {
        if (!p1 || !p2)
          return false;
        
        p1->m_partner = p2;
        p2->m_partner = p1;

        std::cout << p1->m_name << " is partnered with " << p2->m_name << "\n";

        return true;
    }

    const std::string& GetName() const
    {
        return m_name;
    }
};

int main()
{
    auto lucy = std::make_shared<Person>("Lucy");
    auto ricky = std::make_shared<Person>("Ricky");
    
    PartnerUp(lucy, ricky);

    return 0;
}
```
```text
- 출력 -

Lucy created
Ricky created
Lucy is partnered with Ricky
Ricky destroyed
Lucy destroyed
```

- `weak_ptr`
  - 하나 이상의 `shared_ptr`가 소유하는 객체에 대한 접근을 제공하지만 소유자의 수에는 포함되지 않고 레퍼런스 카운트에 포함되지 않음
  - 일반 포인터와 `shared_ptr` 사이에 위치한 스마트 포인터
  - 자동으로 할당 해제해주고 객체에 안전하게 참조할 수 있게 해주지만 `shared_ptr`과 달리 참조 개수를 늘리지 않음(약한 참조)

**주의할 점**  

- `weak_ptr` 자체로는 소유하고 있는 객체의 멤버나 포인터에 접근할 수 없어서 그러기 위해선 반드시 `shared_ptr`로 변환해 사용해야 함
  - `lock()` 함수를 통해 실현
- `weak_ptr`은 오직 `shared_ptr`이나 `weak_ptr`만 대입 및 할당받을 수 있고 직접적인 데이터의 주소를 대입할 수 없음
- 따라서 `lock()` 함수로 `shared_ptr`을 리턴받아 이를 통해 접근해야 함

**lock() 함수**  

- `weak_ptr` 내부에 정의되어 있음
- `weak_ptr`이 가리키는 객체가 아직 메모리에 살아있다면 해당 객체를 가리키는 `shared_ptr`을 리턴하고 이미 해제되었다면 아무것도 가리키지 않는 `shared_ptr`을 리턴함

```cpp
#include <iostream>
#include <memory>
#include <string>

class Person
{
private:
    std::string m_name;
    std::weak_ptr<Person> m_partner;

public:
    Person(const std::string& name) : m_name(name)
    {
        std::cout << m_name << " created\n";
    }

    ~Person()
    {
        std::cout << m_name << " destroyed\n";
    }

    friend bool PartnerUp(std::shared_ptr<Person>& p1, std::shared_ptr<Person>& p2)
    {
        if (!p1 || !p2)
          return false;
        
        p1->m_partner = p2;
        p2->m_partner = p1;

        std::cout << p1->m_name << " is partnered with " << p2->m_name << "\n";

        return true;
    }

    const std::shared_ptr<Person> GetPartner() const
    {                                            
        return m_partner.lock();
    }                                            

    const std::string& GetName() const
    {
        return m_name;
    }
};

int main()
{
    auto lucy = std::make_shared<Person>("Lucy");
    auto ricky = std::make_shared<Person>("Ricky");
    
    PartnerUp(lucy, ricky);

    std::cout << lucy->GetPartner()->GetName() << std::endl; // Ricky 출력

    return 0;
}
```
```text
- 출력 -

Lucy created
Ricky created
Lucy is partnered with Ricky
Ricky
Ricky destroyed
Lucy destroyed
```

- `weak_ptr`로 소유하고 있는 객체에 접근할 수 없지만 `shared_ptr`로 리턴해 `GetName()`와 같은 멤버 함수에 접근할 수 있음
- 일반 포인터로 접근하려면 `shared_ptr`로 변환 후 `get()` 함수를 거쳐야 함
