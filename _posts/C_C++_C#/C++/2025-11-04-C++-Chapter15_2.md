---
title: "[C++] Chapter 15.2 R-Value References"
date: 2025-11-04 13:44:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 129
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : R-Value References

```cpp
#include <iostream>
using namespace std;

void DoSomething(int& lref) { cout << "L-value ref" << endl; }
void DoSomething(int&& rref) { cout << "R-value ref" << endl; }
int GetResult() { return 100; }

int main()
{
  int x = 5;
  int y = GetResult();
  const int cx = 6;
  const int cy = GetResult();

  /* L-value references */
  int& lr1 = x;
  int& lr2 = cx;    // Error !!!
  int& lr3 = 10;    // Error !!!

  const int& lr4 = x;
  const int& lr5 = cx;
  const int& lr6 = 10;

  /* R-value references */
  int&& rr1 = x;    // Error !!!
  int&& rr2 = cx;   // Error !!!
  int&& rr3 = 10;
  int&& rr4 = GetResult();
  rr3 = 20;

  const int&& rr5 = x;
  const int&& rr6 = cx;
  const int&& rr7 = 10;
  const int&& rr8 = GetResult();

  DoSomething(x);   // L-value reference
  DoSomething(10);    // R-value reference
  DoSomething(GetResult());   // R-value reference
  DoSomething(rr3);   // L-value reference
}
```

- `&`는 L-Value를 참조함
  - 일반 변수같은 L-Value만 참조 가능
  - `const int&`와 같은 const L-Value reference는 L-value, R-Value 모두 참조 가능
- `&&`는 잠시 동안만 저장해놓을 R-Value 인스턴스만 R-Value를 참조함
  - 메모리에 잠깐 존재하다가 사라지는 R-Value만 참조 가능
    - 일반 변수와 상수(`const`)는 L-Value이므로 참조 불가능
    - 상수 리터럴이나 함수 리턴 값 같이 메모리를 잠깐 차지하는 인스턴스만 참조 가능
  - `const int&&`와 같은 const R-Value 또한 R-Value만 참조 가능

### L-value 와 R-value

---

- L-Value
  - 어떤 메모리 공간을 차지하고 있으며 주소를 가짐
  - 왼쪽, 오른쪽 모두 위치 가능
- R-value
  - 잠깐 존재하고 해당 문장이 끝나면 사라지며 메모리 공간은 아주 잠시동안 가진 후 사라짐
  - 반드시 오른쪽에만 위치 가능
    - 주소 값을 취할 수 없기 때문에 `&(R-Value)`는 오류

```cpp
int& func1(int& a) { return a; }    // L-Value Reference 리턴 
int func2(int b) { return b; }    // 일반적인 int 리턴

int a = 5;
int b = 7;

func1(a) = 4;   // a의 값이 4
a = func2(b);   // 리턴 값은 잠깐 존재할 뿐 실행이 끝나면 사라짐

std::cout << &func1(a) << std::endl;
std::cout << &func2(b) << std::endl;    // Error !!!
```

- `func1()`는 인수도 L-Value Reference로 받고 리턴 타입도 L-Value Reference이기 때문에 L-Vlaue로서 작용
- `func2()`는 리턴될 때 R-Value로서 리턴되므로 `&func2(b)`와 같이 주소를 가질 수 없음

### L-value Reference

---

```cpp
int& lr1 = x;
int& lr2 = cx;    // cx는 const int 변수이므로 참조 불가능
int& lr3 = 10;    // 상수도 R-Value인 const int이므로 참조 불가능

const int& lr4 = x;
const int& lr5 = cx;
const int& lr6 = 10;
```

- L-Value만 참조 가능
- `&` 하나를 사용하는 L-Value Reference 자체도 L-Value
  - `int& lr1 = x` 가능
    - `x`는 `const`가 아닌 변수로, `lr1`과 `x`는 동일한 메모리 공간을 가지게 되며 수정이 가능
  - `int& lr2 = cx` 불가능
    - `cx`는 `const` 변수로, `lr2`도 `const`여야 참조 가능
  - `int& lr3 = 10` 불가능
    - R-Value는 참조할 수 없음
- const L-Value Reference는 R-Value도 참조할 수 있음
  - 메모리 공간에 잠깐 있다 없어지지만 앞으로 수정할 수 없으므로 symbolic constant처럼 사용

### R-value References

---

```cpp
int&& rr1 = x;    // x는 L-Value이므로 R-value 참조 불가능
int&& rr2 = cx;   // cx는 const int형 변수인 L-Vaule 참조 불가능
int&& rr3 = 10;   // 상수는 R-value이므로 참조 가능 */
int&& rr4 = GetResult();    // 반환 값도 R-value이므로 참조 가능*/

rr3 = 20;
cout << rr3 << endl;

const int&& rr5 = x;    // x는 L-Value이므로 참조 불가능
const int&& rr6 = cx;   // cx는 L-Value이므로 참조 불가능
const int&& rr7 = 10;   // 10은 R-Value이므로 참조 가능
const int&& rr8 = GetResult();    // 반환 값은 R-Value참조 가능
```

- `&&`로 쓰면 R-Value Reference
- 참조 대상은 오직 R-Value여야만 함
- Move Semantics를 사용할 수 있을지 판별할 때 사용
- R-Value Reference 자체는 L-Value이고, R-Value를 받는 기능이 아님
- `int&& rr3 = 10`
  - 10이라는 R-Value의 곧 사라질 임시 공간은 R-Value Reference 타입인 `rr3`으로만 접근하고 수정할 수 있다는 의미가 강함

### L-Value/R-Value Reference 파라미터

---

- `void DoSomething(int& lref)` : L-Value Reference를 인수로 받음
- `void DoSomething(int&& rref)` : R-Value Reference를 인수로 받음

- 컴파일러는 두 함수가 다르다고 인식함, 즉 오버로딩으로 인식
  - `&`와 `&&`는 다르다고 인삭하여 인수 타입이 다르다고 인식함
- L-Value Reference로 넘겨받은 L-Value를 함수 밖에서 다시 쓰려고 하면 **Move Semantics 문제**가 생길 수 있음
- R-Value Reference는 Move Semantics 문제가 생기지 않음

```cpp
void DoSomething(int& lref) { cout << "L-value ref" << endl; }    // 1
void DoSomething(int&& rref) { cout << "R-value ref" << endl; }   // 2

DoSomething(x);   // x는 L-value이므로 1번이 호출되고 int& left = x 가 됨
DoSomething(10);    // 0은 R-value이므로 2번이 호출되고 int&& rref = 10이 됨
DoSomething(getResult());   // GetResult()은 R-value 이므로 2번이 호출됨
DoSomething(rr3);   // L-value reference이므로 1번이 호출됨
```
