---
title: "[C++] Chapter 9.13 initializer_list"
date: 2025-10-28 16:43:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 89
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : initializer_list

### initializer_list

---

- `#include <initializer_list>`
- 컨테이너의 초기화를 편리하게 할 수 있도록 도와주는 템플릿

```cpp
auto li = { 10, 20, 30 };
```

- `li`의 타입은 `std::initializer_list<int>`
- 중괄호를 사용해 `initializer_list`를 생성할 때 타입이 `auto`라면 `initializer_list` 타입의 객체가 됨

### initializer_list를 인수로 받는 생성자

---

- `initializer_list` 객체를 인수로 받는 생성자를 구현하면, 대입 연산자와 함께 중괄호(`{}`)를 사용해 생성자를 호출할 수 있음

```cpp
#include <iostream>
#include <cassert>
#include <initializer_list>
using namespace std;

class IntArray
{
private:
    unsigned m_length = 0;
    int* m_data = nullptr;
public:
    IntArray(unsigned length) : m_length(length)
    {
        m_data = new int[length];
    }

    IntArray(const std::initializer_list<int> &list) : IntArray(list.size())
    {
        int count = 0;
        for (auto & element : list)
        {
            m_data[count] = element;
            ++count;
        }
    }

    ~IntArray()
    {
        delete[] this->m_data;
    }

    friend ostream& operator <<(ostream& out, IntArray& arr)
    {
        for (unsigned i = 0; i < arr.m_length; i++)
            out << arr.m_data[i] >> " ";
        out << endl;
        return out;
    }
};

int main()
{
    IntArray intArr = { 1,2,3,4,5 };
    cout << intArr << endl;

    return 0;
}
```

- `int` 원소들로 이루어진 중괄호(`{}`)를 인수로 전달하면 `initializer_list` 타입 객체가 됨
- 생성자 초기화 리스트에서 위임 생성자로 `IntArray(list.size())`를 호출
  - `initializer_list`의 함수 중 `size()`는 `initializer_list` 타입 객체 내에 원소의 개수를 리턴
  - `{}` 크기의 동적 배열을 할당받아 그 주소를 `m_data`에 대입
- `IntArray intArr = { 1,2,3,4,5 };`
  - 문제 없이 `IntArray` 타입 객체의 `m_data`가 가리키는 동적 배열 원소로 초기화됨
  - `=` 대입 연산자를 빼도 상관없음

### 주의사항

---

1. `initializer_list` 템플릿은 대괄호(`[]`)를 지원하지 않음
   - 따라서 `initializer_list` 객체에 첨자 `[]`를 사용할 수 없음
2. `initializer_list` 템플릿은 얕은 복사를 실행함
   - 동적 메모리를 사용하는 포인터를 사용하는데 `initializer_list` 객체끼리 복사해야 하는 경우 깊은 복사를 위해 대입 연사자 오버로딩을 구현해야 함
3. `initializer_list` 타입의 참조 객체를 인수로 받는 생성자는 생성자 초기화에 사용되는 `{}`보다 우선됨
   - `{}`로 생성자를 호출하는게 자동 형변환을 막아주어 더 엄격한 호출
   - `initializer_list` 타입의 참조 객체를 인수로 받는 생성자가 구현되어 있다면 `{}`로 생성자 호출시 우선 순위에 주의해야 함
