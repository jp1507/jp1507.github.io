---
title: "[C++] Chapter 15.3 이동 생성자와 이동 대입 연산자"
date: 2025-11-04 13:44:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 129
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 15. 의미론적 이동과 스마트 포인터 : 이동 생성자와 이동 대입 연산자

- 소유권을 박탈시키지 않으면 동시에 두 포인터가 동일한 객체를 소유하게 되므로 한 객체를 메모리 해제 시키면 문제가 발생할 수 있음
- R-Value 객체를 복사, 대입할 때 대처

### 복사 생성자, 대입 연산자 오버로딩

---

- const L-Value Reference를 사용하는 복사 생성자, 대입 연산자 오버로딩
  - 복사, 대입시 소유권 이동, 박탈 문제를 고려해야 함
  - **소유권을 이동**시킬 때 새로운 빈 공간을 만든 후 <u>깊은 복사</u>로 내용물들을 이동시킴
  - **소유권 박탈**시 복사 생성자 혹은 대입 연산자 호출이 끝난 후 기존 공간은 지역 변수이기 때문에 자동으로 사라지므로 수동으로 박탈해줄 필요는 없음

```cpp
#include <iostream>
using namespace std;

class Resource
{
public:
    int* m_data = nullptr;
    unsigned m_length = 0;
public:
    Resource()
    {
        cout << "Resource constructed" << endl;
    }
    Resource(unsigned length)
    {
        cout << "Resource length constructed" << endl;
        this->m_data = new int[length];
        this->m_length = length;
    }
    Resource(const Resource& res)
    {
        cout << "Resource copy constructed" << endl;
        
        Resource(res.m_length);

        for (unsigned i = 0; i < m_length; i++)
            m_data[i] = res.m_data[i];
    }

    ~Resource()
    {
        cout << "Resource destroyed" << endl;
    }

    Resource& operator =(Resource& res)
    {
        cout << "Resource copy assignment" << endl;

        if (&res == this) 
            return *this;
        
        if (this->m_data != nullptr) 
            delete[] m_data;

        m_length = res.m_length;
        m_data = new int[m_length];
        for (unsigned i = 0; i < m_length; i++)
            m_data[i] = res.m_data[i];

        return *this;
    }
};
```
{: file="Resource.h"}

- 복사 생성자
  - 복사할 대상이 되는 객체의 멤버를 생성자 인수로 전달받음
  - `m_data`에 내용물들을 깊은 복사로 이동
- 대입 연산자 오버로딩
  - 대입하려는 대상이 자기 자신인 경우 자기 자신을 리턴
  - 기존 공간 비우기로 메모리 누수 방지
  - 포인터 멤버인 `m_data`에 새로운 공간 할당 후 `m_length` 대입
  - `m_data`에 내용물들을 깊은 복사로 이동

```cpp
#include <iostream>
using namespace std;

template<typename T>
class AutoPtr
{
public:
    T* m_ptr;
public:
    AutoPtr(T* ptr = nullptr) : m_ptr(ptr) 
    {
        cout << "AutoPtr default constructor" << endl;
    }
    ~AutoPtr()
    {
        cout << "AutoPtr destructor" << endl;

        if (m_ptr != nullptr) 
            delete m_ptr;
    }
    AutoPtr(const AutoPtr& a)
    {
        cout << "AutoPtr copy constructor" << endl;

        m_ptr = new T;
        *m_ptr = *a.m_ptr;
    }
    AutoPtr& operator =(const AutoPtr& a)
    {
        cout << "AutoPtr copy assignment" << endl;
        
        if (&a == this)
            return *this;
        if (m_ptr != nullptr) 
            delete m_ptr;

        m_ptr = new T;
        *m_ptr = *a.m_ptr;

        return *this;
    }

    T& operator *() const { return *m_ptr; }
    T* operator ->() const { return m_ptr; }
    bool IsNull() const { return m_ptr == nullptr; }
};
```
{: file="AutoPtr.h"}

```cpp
#include <iostream>
#include "AutoPtr.h"
#include "Resource.h"
#include "Timer.h"
using namespace std;

AutoPtr<Resource> GenerateResource()
{
    AutoPtr<Resource> res(new Resource(10000000));
    return res;
}

int main()
{
    streambuf* orig_buf = cout.rdbuf();
    Timer timer;

    {
      AutoPtr<Resource> main_res;
      main_res = GenerateResource();
    }

    cout.rdbuf(orig_buf);
    cout << timer.elapsed() << endl;
}
```
{: file="main.cpp"}

```text
- 출력 -

AutoPtr default constructor
Resource length constructor
AutoPtr default constructor
AutoPtr copy assignment
Resource default constructor
Resource copy assignment
AutoPtr destructor
Resource destroyed
AutoPtr destructor
Resource destroyed
0.0392126
```

- 복사 생성자와 대입 연산자로 소유권 이동, 박탈 정상 작동
- 실행 순서(Release 모드)
  1. `AutoPtr` 디폴트 생성자
  2. `Resource` 매개변수 1개인 생성자 실행
  3. `AutoPtr` 디폴트 생성자
  4. `AutoPtr` 대입 연산자 오버로딩
       - 대입 연산자의 매개변수 `a`는 `const`인 L-Value Reference이기 때문에 `GenerateResource()` 함수 리턴 값 같은 R-Value도 참조 가능
  5. `Resource` 디폴트 생성자
  6. `Resource` 대입 연산자 오버로딩
  7. 첫 번째 `AutoPtr`, `Resource` 소멸자
  8. 두 번째 `AutoPtr`, `Resource` 소멸자에서

```text
- 출력 -

AutoPtr default constructor
Resource length constructed
AutoPtr default constructor
AutoPtr copy constructor
Resource default constructed
Resource copy assignment
AutoPtr destructor
Resource destroyed
AutoPtr copy assignement
Resource default constructed
Resource copy assignment
AutoPtr destructor
Resource destroyed
AutoPtr destructor
Resource destroyed
```

- Debug 모드에서 실행했을 때 결과
- Release 모드와 달리 `GenerateResource()` 함수의 `res` 리턴 값이 임시 객체에 복사되는 과정에서 `AutoPtr` 복사 생성자를 호출하는 것을 확인할 수 있음
- C++ 컴파일러는 경우에 따라 최적화를 위해 복사 생성자 호출을 생략하는데 Release 모드에선 함수 리턴값이 임시 객체에 복사되는 과정에 대해 복사 생성자 호출을 생략해줌(Copy elision)

### 이동 생성자, 이동 대입 연산자 오버로딩

---

- R-Value Reference(`&&`)를 사용하는 이동 생성자, 이동 대입 연산자 오버로딩

- `AutoPtr&& a`
  - R-Value Reference인 `a`가 참조하는 인스턴스는 메모리에 자리 잡지 않고 잠깐 있다 사라지는 R-Value
- 소유권 이동시 내용물들을 깊은 복사로 이전시킬 필요가 없이 얕은 복사로 주소만 넘겨주면 됨
  - 따라서 복사 생성자, 일반 대입 연산자에 비해 훨씬 빠름
  - 얕은 복사이므로 `Resource`의 대입 연산자 오버로딩은 호출되지 않음
    - `Resource`의 대입 연산자의 매개변수는 `const`가 아닌 `&` 레퍼런스이므로 다른 함수라고 인식되어 오버로딩되지 않음
- 소유권 박탈을 반드시 해주어야 함
  - 별개의 새로운 공간을 만들어 내용물들을 복사한게 아닌 두 포인터가 같은 인스턴스를 가리키게 된 것이므로 복사 대상이 된 포인터의 소유권은 박탈시켜 주어야 함
  - 박탈시키지 않으면 대입 연산자 인수로 이 인스턴스를 참조하게 된 매개변수 `AutoPtr&& a`가 대입 연산자 호출이 종료됨에 따라 소멸자가 호출되어 할당 해제될 수 있기 때문

```cpp
template<typename T>
class AutoPtr
{
public:
    T* m_ptr;
public:
    AutoPtr(T* ptr = nullptr) : m_ptr(ptr) 
    {
        cout << "AutoPtr default constructor" << endl;
    }
    ~AutoPtr()
    {
        cout << "AutoPtr destructor" << endl;

        if (m_ptr != nullptr) 
            delete m_ptr;
    }

    AutoPtr(AutoPtr && a) : m_ptr(a.m_ptr)
    { 
        cout << "AutoPtr move constructor" << endl;
        a.m_ptr = nullptr;
    }

    AutoPtr& operator =(AutoPtr&& a)
    {
        cout << "AutoPtr move assignment" << endl;

        if (&a == this)
            return *this;
        if (m_ptr != nullptr) 
            delete m_ptr; 
        
        m_ptr = a.m_ptr;
        a.m_ptr = nullptr;

        return *this;
    }

    T& operator *() const { return *m_ptr; }
    T* operator ->() const { return m_ptr; }
    bool IsNull() const { return m_ptr == nullptr; }
};
```
{: file="AutoPtr.h"}

```cpp
#include <iostream>
#include "AutoPtr.h"
#include "Resource.h"
#include "Timer.h"
using namespace std;

AutoPtr<Resource> GenerateResource()  
{
    AutoPtr<Resource> res(new Resource(10000000));
    return res;
}

int main()
{
    streambuf * orig_buf = cout.rdbuf();
    Timer timer;

    {
      AutoPtr<Resource> main_res;
      main_res = generateResource();
    }

    cout.rdbuf(orig_buf);
    cout << timer.elapsed() << endl;
}
```
{: file="main.cpp"}

```text
- 출력 -

AutoPtr default constructor
Resource length constructor
AutoPtr default constructor
AutoPtr copy assignment
AutoPtr destructor
AutoPtr destructor
0.00590591
```

- 깊은 복사를 하지 않는 것을 확인할 수 있음
  - `Resource`의 복사 생성자가 호출되지 않음
  - 실행 시간 또한 복사 생성자, 대입 연산자 오버로딩에 비해 더 빠른 것을 볼 수 있음

### 정리

---

- R-Value 인스턴스를 대입, 복사할 때에 대처 방법에는 깊은 복사와 얕은 복사가 있는데 깊은 복사보다 **얕은 복사가 더 빠름**

```cpp
AutoPtr<Resource> main_res;
main_res = GenerateResource();    // R-Value
```

**깊은 복사**  

```cpp
// AutoPtr 대입 연산자 
m_ptr = new T;
*m_ptr = *a.m_ptr; // 깊은 복사를 하는 Resource의 대입 연산자 호출

// Resource 대입 연산자 호출
m_data = new int[m_length];
for (unsigned i = 0; i < m_length; i++)
    m_data[i] = res.m_data[i];
```

**얕은 복사**  

```cpp
// AutoPtr의 대입 연산자 
m_ptr = a.m_ptr; // 얕은 복사로, Resource의 대입 연산자 호출하지 않음
a.m_ptr = nullptr;
```

#### R-Value를 무사히 전달받기 위한 첫 번째 방법 : const L-Value Reference

- L-Value, R-Value 모두 참조 가능
- `const`라 참조하는 대상의 값을 수정할 수 없으므로 소유권 박탈 불가능
  - 소유권 이동시 별개의 인스턴스를 만들어 그 곳에 내용물들을 모두 복사해서 옮김(깊은 복사)
  - 얕은 복사는 할 수 없고 깊은 복사만 가능
    - `const`이기 때문에 값을 `nullptr`로 박탈할 수 없기 때문에 소유권 박탈은 불가능하여 얕은 복사를 할 수 없음
    - 엄밀히 말해 별개의 인스턴스이므로 동일한 인스턴스의 소유권 이동이 아니라 복사만 한 셈
- 장점 : L-Value 참조도 가능하므로 유연함
- 단점 : 깊은 복사만 가능하기 때문에 속도가 느림

#### R-Value를 무사히 전달받기 위한 두 번째 방법 : R-Value Reference

- R-Value만 참조 가능
- `const`가 아니기 때문에 참조하는 대상의 값을 수정할 수 있으므로 소유권 박탈이 가능함
  - 소유권 이동시 포인터만 복사하므로 동일한 인스턴스에 대한 소유권이 두 포인터에게 있게 됨(얕은 복사)
  - 현재 인스턴스의 소유권을 두 포인터가 가지고 있으므로 반드시 기존 포인터의 소유권을 박탈시켜 주어야함
- 장점 : 얕은 복사를 사용하므로 속도가 빠름
- 단점 : 오직 R-Value만 참조 가능함

### 복사 생략

---

- 컴파일러는 불필요한 복사 생성자 호출을 막기 위해 일부 경우에 대해 복사를 생략함

```cpp
#include <iostream>

class A
{
private:
    int data_;
public:
    A(int data) : data_(data)
    { 
        std::cout << "일반 생성자 호출!" << std::endl;
    }
    A(const A& a) : data_(a.data_)
    {
        std::cout << "복사 생성자 호출!" << std::endl;
    }
};

int main()
{
    A a(1);  // 일반 생성자 호출
    A b(a);  // 복사 생성자 호출

    A c(A(2)); // 일반 생성자만 호출
}
```

- `A c(A(2));`
  - R-Value인 익명 객체 `A(2)`가 생성되면서 일반 생성자가 호출됨
  - `A(2)`를 복사하여 `c`를 생성하며 복사 생성자가 호출될 것 같지만 실제론 복사 생성자가 호출되지 않음
    - 굳이 복사하기 보단 `c` 자체를 `A(2)`로 만들어진 객체로 하는 것이 더 성능적으로 나음
- 이처럼 컴파일러 판단하에 복사를 생략해 버리는 작업을 **복사 생략**이라고 함
