---
title: "[C++] Chapter 13.4 함수 템플릿 특수화"
date: 2025-11-02 13:35:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 117
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 13. 템플릿 : 함수 템플릿 특수화

- 특수화 : 템플릿에서 특정 타입에 대해 다른 실행 처리를 하고 싶을 때 그 타입에 대해서만 특수화

### 일반 전역 함수의 특수화

```cpp
#include <iostream>
using namespace std;

template<typename T>
T GetMax(T x, T y)
{
    return (x > y) ? x : y;
}

int main()
{
    cout << GetMax(1, 2) << endl;
    cout << GetMax<double> (1, 2) << endl;

    return 0;
}
```

**`char` 타입으로 구체화할 때만 예외적으로 처리해주고 싶을 때**

- `if-else` 문은 런타임 때 결정되므로 사용할 수 없음

```cpp
#include <iostream>
using namespace std;

template<typename T>
T GetMax(T x, T y)
{
    return (x > y) ? x : y;
}

template<>
char GetMax(char x, char y)
{
    cout << "경고! 문자 끼리 비교할 때는 주의 해주세요" << endl;

    return (x > y) ? x : y;
}

int main()
{
    cout << GetMax('a' , 'b') << endl;
    return 0;
}
```

- `template<>`를 붙인 후 특정 타입에 대해 한번 더 정의함

### 멤버 함수의 특수화

---

```cpp
#include <iostream>
using namespace std;

template<typename T>
class Storage
{
private:
    T m_value;
public:
    Storage(T value)
    {
        m_value = value;
    }

    void Print()
    {
        cout << m_value << endl;
    }
};

template<>
void Storage<double>::Print()
{
    cout << "This is Double Type" << endl;
    cout << m_value << endl;
}

int main()
{
    Storage<int> nValue(5);
    Storage<double> dValue(3.14);

    nValue.Print();
    dValue.Print();

    return 0;
}
```

- 클래스 바깥에서 해당 타입에 대해 `template<>`을 붙인 후 한번 더 정의함

**주의사항**  

- 멤버 함수 특수화 코드를 소스 파일에 따로 정의하면 안됨
  - 특수화도 틀일 뿐 구체화된 것이 아님
- 특수화도 마찬가지로 헤더 파일에 정의하는 것을 권장
