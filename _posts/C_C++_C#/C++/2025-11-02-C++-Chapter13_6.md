---
title: "[C++] Chapter 13.6 함수 부분 특수화"
date: 2025-11-02 13:55:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 119
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 13. 템플릿 : 함수 부분 특수화

- 특수화 : 템플릿에서 특정 타입에 대해 다른 실행 처리를 하고 싶을 때 그 타입에 대해서만 특수화

### 부분 특수화

---

- 완전 특수화 : 템플릿 매개변수들을 모두 특수화함
- 부분 특수화 : 템플릿 매개변수들이 여러 개일 때 일부만 특수화함
  - 전역 함수의 경우 문제없이 가능
  - 멤버 함수의 경우 클래스 외부에선 부분 특수화 불가능하지만
    - 클래스 내부만 가능하므로 상속을 이용함

### 일반 전역 함수를 부분 특수화

---

**특수화 하기 전**  

```cpp
#include <iostream>
using namespace std;

template<typename T, int size>
class StaticArray
{
private:
    T m_array[size];
public:
    T* GetArray() { return m_array; }
    T& operator [](int index)
    {
        return m_array[index];
    }
};

template<typename T, int size>
void Print(StaticArray<T, size>& array)
{
    for (int cnt = 0; cnt < size; cnt++)
        cout << array[cnt] << ' ';
    cout << endl;
}

int main()
{
    StaticArray<int, 4> int4;
    int4[0] = 1;
    int4[1] = 2;
    int4[2] = 3;
    int4[3] = 4;
    Print(int4);
    // 1 2 3 4 출력

    StaticArray<char, 14> char14;
    strcpy_s(char14.GetArray(), 14, "Hello, World");
    Print(char14);
    // Hello, World ? 출력

    return 0;
}
```

- `char` 타입으로 특수화되었을 때 출력에 공백이 생기지 않도록 수정할 수 있음

**특수화 하기**  

```cpp
template<int size>
void Print(StaticArray<char, size>& array)
{
    for (int cnt = 0; cnt < size; cnt++)
        cout << array[cnt];
    cout << endl;
}
```
```text
-출력-

1 2 3 4
Hello, World
```

### 매개변수가 있는 멤버 함수를 특수화

---

**문제점**  

- 멤버 함수를 특수화하기 까다로움
  - `Print()`가 멤버 함수라면 매개변수가 없는 `Print()`로 표현됨
- 특수화는 클래스 밖에서 이루어지는데 매개변수가 없으니 `*(this)`를 표현하는 것이 까다로움
- 이는 상속과 오버라이딩으로 해결할 수 있음

**해결책**  

- 자식 클래스를 특수화 하면서 그 안에 오버라이딩을 하면 `*this` 사용이 가능함

```cpp
#include <iostream>
#include <stdio.h>

using namespace std;

template<typename T, int size>
class StaticArray_BASE
{
private:
    T m_array[size];
public:
    T* GetArray() { return m_array; }
    T& operator [] (int index)
    {
        return m_array[index];
    }

    void Print()
    {
        for (int cnt = 0; cnt < size; cnt++)
            cout << (*this)[cnt] << ' ';
        cout << endl;
    }
};

template<typename T, int size>
class StaticArray : public StaticArray_BASE<T, size>
{
};

template<int size>
class StaticArray<char, size> : public StaticArray_BASE<char, size>
{
public:
    void Print()
    {
        for (int cnt = 0; cnt < size; cnt++)
            cout << (*this)[cnt];
        cout << endl;
    }
};

int main()
{
    StaticArray<int, 4> int4;
    int4[0] = 1;
    int4[1] = 2;
    int4[2] = 3;
    int4[3] = 4;
    int4.Print();

    StaticArray<char, 14> char14;
    strcpy_s(char14.GetArray(), 14, "Hello, World");
    char14.Print();

    return 0;
}
```

1. `StaticArray` 클래스 이름을 `StaticArray_BASE`로 바꿔 기존 클래스를 부모 클래스로 함
2. `StaticArray_BASE`를 상속하는 `StaticArray` 자식 클래스를 빈 클래스로 만듦
3. 빈 자식 클래스인 `StaticArray` 자식 클래스를 특수화하고 그 안에서 오버라이딩해줌
