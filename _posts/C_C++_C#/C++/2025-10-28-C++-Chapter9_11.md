---
title: "[C++] Chapter 9.11 변환 생성자, explicit, delete"
date: 2025-10-28 15:48:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 87
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 9. 연산자 오버로딩 : 변환 생성자, explicit, delete

- 생성자를 명확히 호출하고 비효율적인 호출들을 방지하기 위한 방법

### 변환 생성자

---

```cpp
#include <iostream>
#include <cassert>
using namespace std;

class Fraction
{
private:
    int m_numerator;
    int m_denominator;
public:
    Fraction(int num = 0, int den = 1) : m_numerator(num), m_denominator(den)
    {
        assert(den != 0); 
    }
    Fraction(const Fraction &fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator)
    { 
        cout << "Copy constructor called" << endl; 
    }
    friend std::ostream& operator <<(std::ostream& out, const Fraction& f)
    {
        out << f.m_numerator << " / " << f.m_denominator << endl;
        return out;
    }
};

void DoSomething(Fraction frac)
{
    cout << frac << endl;
}

int main()
{
    DoSomething(7);
    return 0;
}
```

- `DoSomething(7)` 호출 시 `Fraction` 타입 객체를 인수로 받는데도 불구하고 `int` 타입인 7을 인수로 넘겨도 문제 없음
- 함수 내부의 매개변수 임시 객체인 `frac`이 생성되었기 때문
- 컴파일러가 자동 형변환을 해주기 때문에 이러한 경우가 발생할 수 있으며 이런 생성자를 **변환 생성자**라고 함

**변환 생성자의 단점**  

1. 논리성이 떨어짐
   - 특정 타입 객체를 인수로 받는다고 명시했지만 컴파일러가 자동 형변환으로 다른 타입을 사용해도 문제가 없기 때문
   - `int`로 변환될 수 있는 `char` 타입 등을 인수로 사용해도 변환 생성자가 호출되는 문제가 발생함
2. 메모리가 낭비됨
   - 임시 객체를 생성하고 소멸하는 과정이 생기기 때문

### 생성자 명확히 호출하기

---

**explicit**  

- 생성자 앞에 `explicit` 키워드를 붙여 변환 생성자의 무작위 호출을 막고 명확성을 높임

```cpp
explicit Fraction(int num = 0, int den = 1) : m_numerator(num), m_denominator(den)
{
    assert(den != 0); 
}

DoSomething(7);   // Error !!!
```

**delete**  

- 생성자에 `delete` 키워드를 붙여 특정 타입의 인수를 받지 않도록 막을 수 있음
- 동적 할당 해제의 `delete`와 다름

```cpp
Fraction(const Fraction& frac) = delete;
```

- 복사 생성자가 구현되어있지 않은 경우 기본 복사 생성자를 호출하고 싶지 않게 막을 수 있음

```cpp
Fraction(char) = delete;

...

Fraction frac('c');   // Error !!!
```

```cpp
#include <iostream>
#include <cassert>
using namespace std;

class Fraction
{
private:
    int m_numerator;
    int m_denominator;
public:
    Fraction(char) = delete;
    explicit Fraction(int num = 0, int den = 1) : m_numerator(num), m_denominator(den)
    {
        assert(den != 0); 
    }

    Fraction(const Fraction &fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator)
    { 
        cout << "Copy constructor called" << endl; 
    }

    friend std::ostream& operator <<(std::ostream& out, const Fraction& f)
    {
        out << f.m_numerator << " / " << f.m_denominator << endl;
        return out;
    }
};

void DoSomething(Fraction frac)
{
    cout << frac << endl;
}

int main()
{
    DoSomething(7);   // Error !!!
    Fraction frac('c');   // Error !!!

    return 0;
}
```
