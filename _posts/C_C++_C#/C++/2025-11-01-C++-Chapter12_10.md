---
title: "[C++] Chapter 12.10 동적 형변환"
date: 2025-11-01 15:04:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 112
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 12. 가상 함수 : 동적 형변환

### dynamic_cast

---

- 동적으로 형변환시키며, 실패할 경우 `nullptr`을 반환

```cpp
#include <iostream>
#include <string>

using namespace std;

class Base
{
public:
    int m_i = 0;

    virtual void Print()
    {
        cout << "I'm Base" << endl;
    }
};

class Derived1 : public Base
{
public:
    int m_j = 1024;

    virtual void Print() override
    {
        cout << "I'm derived_1" << endl;
    }
};

class Derived2 : public Base
{
public:
    string m_name = "Dr. Two";

    virtual void Print() override
    {
        cout << "I'm derived_2" << endl;
    }
};

int main()
{
    Derived1 d1;
    Base* base = &d1;

    auto* base_to_d1 = dynamic_cast<Derived1*>(base);
    cout << base_to_d1->m_j << endl;

    return 0;
}
```

- `auto* base_to_d1 = dynamic_cast<Derived1*>(base);`
  - `Derived1` 객체를 가리키는 `Base*` 포인터는 객체와 타입이 일치하기 때문에 `Derived1*` 포인터로 형변환이 가능
  - `Base` 타입이지만 `Derived` 객체인 `d1`의 주소를 담고 있는 `base` 포인터가 `Derived1*` 포인터 타입으로 형변환되며 `d1`의 주소를 리턴함

```cpp
int main()
{
    Derived1 d1;
    Base* base = &d1;

    auto* base_to_d1 = dynamic_cast<Derived2*>(base);

    if (base_to_d1 != nullptr)
        cout << base_to_d1->m_name << endl;
    else
        cout << "Failed" << endl;

    // Failed 출력

    return 0;
}
```

- 상속 관계가 아니고 타입이 전혀 다르기 때문에 `Derived1` 객체를 가리키는 `Base*` 포인터를 `Derived2` 포인터로 형변환하는 것은 불가능
- 이때 `dynamic_cast`에서 형변환에 실패했으므로 `nullptr`을 리턴

### static_cast

---

```cpp
auto *base_to_d1 = static_cast<Derived2*>(base);
```

- 원래는 형변환에 실패하지만 `static_cast`는 강제로 형변환
- 런타임 에러를 체크하지 않고 최대한 개발자가 원하는 형으로 변환시켜주려고 하기 때문에 안되는 것이 되는 경우가 있음

**이와 같은 문제로 `static_cast`보단 `dynamic_cast`를 더 권장하지만 다형성에 있어 형변환을 쓰는 것은 지양**

- 형변환을 하면서 데이터 손실로 위험할 수 있기 때문
