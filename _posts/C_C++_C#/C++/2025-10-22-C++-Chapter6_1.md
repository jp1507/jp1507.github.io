---
title: "[C++] Chapter 6.1 배열"
date: 2025-10-22 13:33:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 28
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## 배열

---

- 동일한 크기의 연속된 메모리 공간을 가짐

```cpp
int a = 1;
int b = 2;
int c = 3;

int num[3] = {1, 2, 3};
```

- 변수를 하나 하나 선언하기보단 `num`이라는 배열로 한번에 관리하는 것이 더 효율적
- `int`를 담을 수 있는 4 byte 크기의 메모리 공간이 연속으로 3개 붙어있는 것

## 배열의 선언과 초기화

---

```cpp
int a[3] = {1, 2, 3};
int a[] = {1, 2, 3};  // 배열의 크기를 명시하지 않아도 초기화를 통해 추론
int a[5] = {1, 2};    // 배열 원소의 일부만 초기화 가능
int a[5];             // 초기화 안하고 사용 가능
int a[];              // Error !!! 크기를 추론할 수 없음
int a[]{1, 2, 3}      // C++ 11 이상부터 지원
```

## 응용

---

**구조체 배열**  

```cpp
struct Rect
{
  int width;
  int height;
};

int main()
{
  cout << sizeof(Rect) << endl;     // 8 출력
  Rect rect_arr[10];
  cout << sizeof(rect_arr) << endl; // 80 출력
  return 0;
}
```

**배열의 인덱스로 `enum` 사용**  

---

```cpp
enum StudentName
{
  JACKJACK,     // 0
  DASH,         // 1
  VIOLET,       // 2
  NUM_STUDENTS, // 3
};

int main()
{
  int my_array[NUM_STUDENTS];
 
  my_array[JACKJACK] = 1; // my_array[0] = 1;
  my_array[DASH] = 100;   // my_array[1] = 100;

  return 0;
}
```

## 배열의 크기는 컴파일 타임에 결정

---

```cpp
int num_students = 0;
cin >> num_students;

int students_scores[num_students]; // Error !!!
```

- 배열의 크기는 컴파일 타임에 결정되어야하므로 런타임 변수에 의해 배열의 크기를 설정할 수 없음
- 런타임에 배열의 크기가 정해지는 것은 **동적 배열**이라고 함

```cpp
int a = 2;
int b[a]; // Error !!!

const int a = 2;
int b[a];
```

- `const` 변수는 컴파일 타임 상수이므로 배열의 크기로 사용할 수 있음

## 배열의 변수는 배열의 첫 번째 원소의 주소 값

---

```cpp
#define NUM_STUDENTS 100000

int main()
{
  int students_scores[NUM_STUDENTS];

  cout << (int)&students_scores << endl; 
  cout << (int)&students_scores[0] << endl;
  cout << (int)&students_scores[1] << endl;
  cout << (int)&students_scores[2] << endl;
  cout << (int)&students_scores[3] << endl;

  cout << sizeof(students_scores) << endl;

  return 0;
}
```

- 배열의 변수는 인덱스가 0인 원소의 주소 값을 담고 있기 때문에 `(int)&students_scores`와 `(int)&students_scores[0]`은 동일한 값을 반환
- 출력 결과를 보면 주소 값이 4씩 차이가 나는데 이는 `int` 타입 원소의 크기가 4 byte이기 때문

```cpp
using namespace std;

void DoSomething(int students_scores[20]) // 배열 포인터
{
  cout << (int)&students_scores << endl;
  cout << (int)&students_scores[0] << endl;
  cout << students_scores[0] << endl; 
  cout << students_scores[1] << endl;
  cout << students_scores[2] << endl;
}

int main()
{
  const int num_studnets = 20; 
  int students_scores[num_studnets] = { 1, 2, 3, 4, 5, };

  cout << (int)students_scores << endl;
  cout << (int)&students_scores << endl;
  cout << students_scores[0] << endl;
  cout << students_scores[1] << endl;
  cout << students_scores[2] << endl;

  DoSomething(students_scores);

  return 0;
}
```

- `DoSomething()` 함수의 매개변수인 `int student_scores[20]`은 배열이 아닌 배열의 주소를 가진 포인터
  - `[20]`도 단순히 크기가 20인 배열을 받을 포인터라는 의미가 없는 코드이고, 크기 또한 하나의 주소 값을 갖는 `int *`로 4 byte임
  - 포인터 변수로, `students_scores`의 첫 번째 주소 값을 복사하여 넘겨 받음
- `DoSomething()`의 `(int)&students_scores`와 `(int)&students_scores[0]`는 다름
  - `(int)&students_scores`는 포인터의 포인터이기 때문에 `(int)&students_scores[0]`와 다른 값이 출력됨
