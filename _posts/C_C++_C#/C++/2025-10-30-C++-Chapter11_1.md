---
title: "[C++] Chapter 11.1 상속의 기본"
date: 2025-10-30 13:33:00 +0900
categories: ["C, C++, C#", C++]
tags: [programming, cpp, 프로그래밍, C++]
series: "따라하며 배우는 C++"
series_order : 95
math: true
image:
  path: https://imgur.com/Eqg7DeC.jpg
---

## Chapter 11. 상속 : 상속의 기본

- **Is-A** 관계
- `클래스 이름 : 부모 클래스 이름`

### 코드 재사용

---

- 공통적으로 가지는 특성과 기능을 **부모 클래스**로 한 곳에 묶고 이를 상속받아 코드를 재사용함

```cpp
#include <string>
#include <iostream>

class Person
{
private:
    std::string m_name; 

public:
    Person(const std::string & name_in = "No Name") :m_name(name_in) {}

    void SetName(const std::string& name_in)
    {
        m_name = name_in;
    }

    std::string GetName() const
    {
        return m_name;
    }

    void DoSomething()
    {
        cout << "Person!" << endl;
    }
};
```
{: file="Person.h"}

```cpp
#pragma once
#include "Person.h"

class Student : public Person
{
    // 빈 클래스
};
```
{: file="Student.h"}

```cpp
#include "Person.h"
#include "Student.h"
using namespace std;

int main()
{
    Person person;
    person.setName("사람");
    cout << person.GetName() << endl;

    Student student;
    student.setName("사람");
    cout << student.GetName() << endl;

    cout << sizeof(student) << endl;
}
```
{: file="main.cpp"}

- `Student` 클래스는 빈 클래스임에도 불구하고 부모 클래스인 `Person`의 멤버들을 모두 상속받아 가지고 있음
- 따라서 `Student` 클래스는 빈 클래스임에도 불구하고 `student` 객체의 사이즈를 출력하면 8
  - `Person`의 멤버 변수인 `m_name`의 크기
  - `private` 멤버 변수도 모두 상속되지만 자식 클래스에서 접근이 안됨

### 오버라이딩

---

- 부모로부터 상속받은 멤버 함수의 내용을 새롭게 다시 정의하는 것
  - 함수 프로토타입은 동일하지만 내용을 다르게 구현
- C++은 포인터 혹은 참조하는 변수가 어떤 타입인지에 따라 호출할 멤버를 결정
  - `Person` 클래스에 `DoSomething()` 멤버가 있으므로 `Student` 클래스에도 `DoSomething()`이 상속됨
  - 이 때, `Student` 클래스 내 동일 함수를 재정의하면 `Student` 객체에서 재정의(오버라이딩)한 `DoSomething()`이 호출됨

```cpp
#include <string>
#include <iostream>

class Person
{
private:
    std::string m_name; 

public:
    Person(const std::string & name_in = "No Name") :m_name(name_in) {}

    void SetName(const std::string& name_in)
    {
        m_name = name_in;
    }

    std::string GetName() const
    {
        return m_name;
    }

    void DoSomething()
    {
        cout << "Person!" << endl;
    }
};

```
{: file="Person.h"}

```cpp
#pragma once
#include "Person.h"

class Student : public Person
{
public:
    void DoSomething()
    {
        cout << "Student!" << endl;
    }
};
```
{: file="Student.h"}

```cpp
#include "Person.h"
#include "Student.h"

int main()
{
    Person person;
    Student student;

    person.doSomething();   // Person! 출력
    student.doSomething();    // Studenet! 출력
}
```
{: file="main.cpp"}

### 접근 지정자

---

- 부모 클래스의 멤버 변수는 `private` 권장
  - 부모의 멤버 변수들은 자식 클래스들에게 상속되기 때문에 자식 클래스에서 멤버 값을 직접 접근할 수 있게 됨
  - 이 멤버를 삭제하거나 수정하게 되면 자식 클래스에서 직접 사용하던 부분들까지 모두 수정해야하는 번거로움 발생
  - 상위 클래스의 멤버 변수들을 모두 `private`으로 사용하고 이에 대한 접근 함수를 구현하는 것이 좋음
- 멤버 변수가 `protected`라면 자식 클래스들에게 접근을 허용하지만 외부에선 못하도록 방지하는 것이므로 상속에 있어서는 `public`과 동일

### 생성자

---

- 자식 객체가 생성될 때, 항상 부모 생성자가 먼저 호출됨
  - 부모로부터 물려받은 멤버들을 정의하고 초기화해야하기 때문

**생성자 호출 및 처리 순서**  

1. 생성자의 인수를 받는 부분
2. 생성자 초기화 리스트 부분
   - 메모리 할당
   - 부모 생성자 호출
3. 자신의 생성자 중괄호(`{}`) 부분
   - 자신의 멤버 초기화

**생성자 초기화 리스트에서 부모 멤버를 초기화시킬 수 없음**  

```cpp
#include <string>
#include <iostream>

class Person
{
private:
    std::string m_name; 
public:
    Person(const std::string & name_in = "No Name") :m_name(name_in)
    {
        cout << "부모 생성자 호출" << endl;
    }
};
```
{: file="Person.h"}

```cpp
#pragma once
#include "Person.h"

class Student : public Person
{
private:
    int m_intel;
public:
    // Error !!!
    Student(const std::string & name_in = "No Name", const int & intel_in = 0) : m_intel(intel_in),  m_name(name_in)
    {
        cout << "자식 생성자 호출" << endl;
    }
};
```
{: file="Student.h"}

- `Student` 자식 클래스의 생성자 초기화 리스트에서 바로 부모의 멤버 변수를 초기화할 수 없음
  - 아직 부모 생성자가 호출되기 전이기 때문에 부모 멤버들의 메모리가 정의되지 않은 상태

**해결1 : 부모의 접근 함수 호출**  

```cpp
#pragma once
#include "Person.h"

class Student : public Person
{
private:
    int m_intel;
public:
    Student(const std::string & name_in = "No Name", const int & intel_in = 0) : m_intel(intel_in)
    {
        Person::setName(name_in);
        cout << "자식 생성자 호출" << endl;
    }
};
```
{: file="Student.h"}

**해결2 : 초기화 리스트에서 부모 생성자 직접 호출**  

```cpp
#pragma once
#include "Person.h"

class Student : public Person
{
private:
    int m_intel;
public:
    Student(const std::string & name_in = "No Name", const int & intel_in = 0) : m_intel(intel_in), Person(name_in)
    {
        cout << "자식 생성자 호출" << endl;
    }
};
```
{: file="Student.h"}

**주의 사항**  

- 위 해결책들에선 `Person`의 생성자 인수의 디폴트 값을 정의했기 때문에 인수를 1개 받는 생성자지만 인수가 없는 디폴트 생성자로도 역할할 수 있어 문제가 없음

```cpp
#pragma once
#include "Person.h"

class Student : public Person
{
private:
    int m_intel;
public:
    Student(const std::string& name_in = "No Name", const int& intel_in = 0)
    {
        cout << "자식 생성자 호출" << endl;
    }
};
```
{: file="Student.h"}

- 위 코드와 같이 자식 생성자에서 부모 생성자의 디폴트 생성자를 호출해야할 때, 부모의 디폴트 생성자가 없을 경우 *"no matching function for call to ‘Person::Person()’"* 에러가 발생함
